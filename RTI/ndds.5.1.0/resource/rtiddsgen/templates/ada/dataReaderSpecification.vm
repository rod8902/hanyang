##/* $Id: dataReaderSpecification.vm,v 1.6 2013/06/27 15:59:41 aida Exp $
##
##   (c) Copyright, Real-Time Innovations, Inc. 2001.  All rights reserved.
##   No duplications, whole or partial, manual or electronic, may be made
##   without prior written permission.  Any such copies, or
##   revisions thereof, must display this notice unaltered.
##   This code contains trade secrets of Real-Time Innovations, Inc.
##modification history:
##---------------------
##10a,10jun13,ajm CODEGENII-109 adding envMap and constructMapList variables
##10a,25oct12, ajm Refactorizing code and variable names.
##                 RRTIDDSGEN-32 support for -use42eAlignment and -generateCTypecode
##10a,10oct12, ajm Upgrade to Bigpine.Formatting and commenting
##10a,11nov11, ajm Changing the name of the templates to camelCase
##10a,04nov11, ajm Refactoring code. Variable name changed
##10a,16ag11,ajm Adding funcionality for basic types, const and arrays
##10a,15ag11,jmt created 
##
##========================================================================*/
--  ============================================================================
--
--         WARNING: THIS FILE IS AUTO-GENERATED. DO NOT MODIFY.
--
--  This file was generated from ${envMap.idlFileName}.idl using "rtiddsgen".
--  The rtiddsgen tool is part of the RTI Connext distribution.
--  For more information, type 'rtiddsgen -help' at a command shell
--  or consult the RTI Connext manual.
--
--  ============================================================================

pragma Warnings (Off); --  Since this is autogenerated code.

with DDS.DataReader;
with DDS.DataReader_Impl;
with DDS.ReadCondition;

with ${constructMap.packageName}; use ${constructMap.packageName};
pragma Warnings (On);
package ${constructMap.nativeFQName}_DataReader is

   type Ref is new Standard.DDS.DataReader_Impl.Ref with null record;
   type Ref_Access is access all Ref'Class;

   procedure Read
     (This            : not null access Ref;
      Received_Data   : not null access ${constructMap.name}_Seq.Sequence;
      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;
      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;
      Sample_States   : in Standard.DDS.SampleStateMask := Standard.DDS.ANY_SAMPLE_STATE;
      View_States     : in Standard.DDS.ViewStateMask := Standard.DDS.ANY_VIEW_STATE;
      Instance_States : in Standard.DDS.InstanceStateMask := Standard.DDS.ANY_INSTANCE_STATE);

   procedure Take
     (This            : not null access Ref;
      Received_Data   : not null access ${constructMap.name}_Seq.Sequence;
      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;
      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;
      Sample_States   : in Standard.DDS.SampleStateMask := Standard.DDS.ANY_SAMPLE_STATE;
      View_States     : in Standard.DDS.ViewStateMask := Standard.DDS.ANY_VIEW_STATE;
      Instance_States : in Standard.DDS.InstanceStateMask := Standard.DDS.ANY_INSTANCE_STATE);

   procedure Read_W_Condition
     (This          : not null access Ref;
      Received_Data : not null access ${constructMap.name}_Seq.Sequence;
      Info_Seq      : not null access Standard.DDS.SampleInfo_Seq.Sequence;
      Max_Samples   : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;
      Condition     : access Standard.DDS.ReadCondition.Ref'Class);

   procedure Take_W_Condition
     (This          : not null access Ref;
      Received_Data : not null access ${constructMap.name}_Seq.Sequence;
      Info_Seq      : not null access Standard.DDS.SampleInfo_Seq.Sequence;
      Max_Samples   : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;
      Condition     : access Standard.DDS.ReadCondition.Ref'Class);

   procedure Read_Next_Sample
     (This          : not null access Ref;
      Received_Data : not null ${constructMap.name}_Access;
      Sample_Info   : not null access Standard.DDS.SampleInfo);

   procedure Take_Next_Sample
     (This          : not null access Ref;
      Received_Data : not null ${constructMap.name}_Access;
      Sample_Info   : not null access Standard.DDS.SampleInfo);

   procedure Read_Instance
     (This            : not null access Ref;
      Received_Data   : not null access ${constructMap.name}_Seq.Sequence;
      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;
      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;
      A_Handle        : access constant Standard.DDS.InstanceHandle_T;
      Sample_States   : in Standard.DDS.SampleStateMask := Standard.DDS.ANY_SAMPLE_STATE;
      View_States     : in Standard.DDS.ViewStateMask := Standard.DDS.ANY_VIEW_STATE;
      Instance_States : in Standard.DDS.InstanceStateMask := Standard.DDS.ANY_INSTANCE_STATE);

   procedure Take_Instance
     (This            : not null access Ref;
      Received_Data   : not null access ${constructMap.name}_Seq.Sequence;
      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;
      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;
      A_Handle        : access constant Standard.DDS.InstanceHandle_T;
      Sample_States   : in Standard.DDS.SampleStateMask := Standard.DDS.ANY_SAMPLE_STATE;
      View_States     : in Standard.DDS.ViewStateMask := Standard.DDS.ANY_VIEW_STATE;
      Instance_States : in Standard.DDS.InstanceStateMask := Standard.DDS.ANY_INSTANCE_STATE);
      
    #*Begin update to 5.0.0*#  
    procedure Read_Instance_W_Condition
     (This            : not null access Ref;
      Received_Data   : not null access ${constructMap.name}_Seq.Sequence;
      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;
      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;
      Previous_Handle : access constant Standard.DDS.InstanceHandle_T;
      Condition       : Standard.DDS.ReadCondition.Ref_Access);
   procedure Take_Instance_W_Condition
     (This            : not null access Ref;
      Received_Data   : not null access ${constructMap.name}_Seq.Sequence;
      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;
      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;
      Previous_Handle : access constant Standard.DDS.InstanceHandle_T;
      Condition       : Standard.DDS.ReadCondition.Ref_Access);
      
   #*End update to 5.0.0*#  
   procedure Read_Next_Instance
     (This            : not null access Ref;
      Received_Data   : not null access ${constructMap.name}_Seq.Sequence;
      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;
      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;
      Previous_Handle : access constant Standard.DDS.InstanceHandle_T;
      Sample_States   : in Standard.DDS.SampleStateMask := Standard.DDS.ANY_SAMPLE_STATE;
      View_States     : in Standard.DDS.ViewStateMask := Standard.DDS.ANY_VIEW_STATE;
      Instance_States : in Standard.DDS.InstanceStateMask := Standard.DDS.ANY_INSTANCE_STATE);

   procedure Take_Next_Instance
     (This            : not null access Ref;
      Received_Data   : not null access ${constructMap.name}_Seq.Sequence;
      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;
      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;
      Previous_Handle : access constant Standard.DDS.InstanceHandle_T;
      Sample_States   : in Standard.DDS.SampleStateMask := Standard.DDS.ANY_SAMPLE_STATE;
      View_States     : in Standard.DDS.ViewStateMask := Standard.DDS.ANY_VIEW_STATE;
      Instance_States : in Standard.DDS.InstanceStateMask := Standard.DDS.ANY_INSTANCE_STATE);

   procedure Read_Next_Instance_W_Condition
     (This            : not null access Ref;
      Received_Data   : not null access ${constructMap.name}_Seq.Sequence;
      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;
      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;
      Previous_Handle : access constant Standard.DDS.InstanceHandle_T;
      Condition       : Standard.DDS.ReadCondition.Ref_Access);

   procedure Take_Next_Instance_W_Condition
     (This            : not null access Ref;
      Received_Data   : not null access ${constructMap.name}_Seq.Sequence;
      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;
      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;
      Previous_Handle : access constant Standard.DDS.InstanceHandle_T;
      Condition       : Standard.DDS.ReadCondition.Ref_Access);

   procedure Get_Key_Value
     (This       : not null access Ref;
      Key_Holder : not null ${constructMap.name}_Access;
      Handle     : access constant Standard.DDS.InstanceHandle_T);

   function Lookup_Instance
     (This       : not null access Ref;
      Key_Holder : not null ${constructMap.name}_Access) return Standard.DDS.InstanceHandle_T;

   procedure Return_Loan
     (This          : not null access Ref;
      Received_Data : not null access ${constructMap.name}_Seq.Sequence;
      Info_Seq      : not null access Standard.DDS.SampleInfo_Seq.Sequence);

   function CreateTypedI return Standard.DDS.DataReader.Ref_Access;

   procedure DestroyTypedI
     (Reader : in out Standard.DDS.DataReader.Ref_Access);

end ${constructMap.nativeFQName}_DataReader;
