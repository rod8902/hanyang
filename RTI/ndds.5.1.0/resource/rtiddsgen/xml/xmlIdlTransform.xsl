<?xml version="1.0"?>
<!-- 
/* $Id: xmlIdlTransform.xsl,v 1.8 2013/09/12 14:22:27 fernando Exp $
 
   (c) Copyright, Real-Time Innovations, Inc. 2001.  All rights reserved.
   No duplications, whole or partial, manual or electronic, may be made
   without prior written permission.  Any such copies, or
   revisions thereof, must display this notice unaltered.
   This code contains trade secrets of Real-Time Innovations, Inc.
 
modification history:
- - - - - - - - - - -
5.0.1,15apr13,acr CODEGEN-573: convert Optional directive
5.0.0,09nov12,fcs Added extensibility and memberID support for valuetypes
5.0.0,11jul12,fcs Bitbound support in enums
1.0ac,09apr11,fcs Fixed bug 13915
1.0ac,08dec10,fcs Added copy-java-begin and copy-java-declaration-begin
10y,17apr09,fcs Removed autogenerated message
10y,18mar09,fcs Support for abstract and truncatable keywords
10y,21nov08,jlv Changed maxLengthSequence for sequenceMaxLength and maxLengthString for
                stringMaxLength in XML format..
10y,17nov08,jlv Solved new bug in long long types.
                Changed the way unions are parsed in XML. Now members are children of cases.
10y,16nov08,jlv Removed sequence='true', now we use maxLengthSequence='-1' for unbounded sequences.
                Added maxLengthString='-1' case.
                Added nonBasic type and nonBasicTypeName attribute.
                Changed some types name.
10y,08nov08,jlv Solved little bug in unions template (added a carriage return).
10y,31oct08,jlv Changed kind='sequence' to sequence='true'. Fixed pointers. Fixed string sequences.
10y,30oct08,jlv Removed 'yes' and 'no' values. Changed ' ' to ',' in dimensions attribute.
                Changed the name of the directives. Added copyCppcli and
                copyCppcliDeclaration directives. Changed dimensions to arrayDimensions.
10y,14oct08,jlv Fixed Error message for duplicated names.
10y,29sep08,jlv maxLength renamed to maxLengthString and maxLengthSequence
10y,17sep08,jlv Removed bounded parameter from XML
10y,20ago08,jlv Removed dds: label from tags
10y,08aug08,jlv Fixed a preprocessor problem with the include directive, added forward template, added typeModifier custom
10y,07aug08,jlv Corrected some bugs (resolve-name in typedef template)
10y,06aug08,jlv Corrected some bugs (string<>, resolve-name and top-level attributes, pointer mark, maxLenght in sequences and typedef template)
10s,16jul08,tk Commented out un-used directive
10s,15feb08,fcs Fixed resolve-name attribute
10s,25jan08,jpm maxLengthString and maxLengthSequence, renamed to maxLength 
10s,21jan08,jpm Created
-->

<!DOCTYPE xsl:stylesheet [
<!ENTITY nl "&#xa;">
<!--   new line  --><!ENTITY indent "    ">
<!-- indentation -->]>

<xsl:transform version="1.0"
               xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:output method="text"/>
  <xsl:strip-space elements="*"/>
  <xsl:include href="typeCommon.c.xsl"/>

<!-- Global Template-->
  <xsl:template match="/">
    <xsl:apply-templates select="*"/>
  </xsl:template>
<!-- Const type -->
  <xsl:template match="const">
    <xsl:call-template name="checkDuplicateName">
      <xsl:with-param name="member" select="."/>
    </xsl:call-template>

    <xsl:text>const </xsl:text>
    <xsl:choose>
      <xsl:when test="@type='string'">
        <xsl:text>string</xsl:text>
        <xsl:if test="@stringMaxLength and @stringMaxLength!='' and @stringMaxLength!='-1'">
          <xsl:text>&lt;</xsl:text>
          <xsl:value-of select="@stringMaxLength"/>
          <xsl:text>&gt;</xsl:text>
        </xsl:if>
        <xsl:text> </xsl:text>
      </xsl:when>
      <xsl:when test="@type='wstring'">
        <xsl:text>wstring</xsl:text>
        <xsl:if test="@stringMaxLength and @stringMaxLength!='' and @stringMaxLength!='-1'">
          <xsl:text>&lt;</xsl:text>
          <xsl:value-of select="@stringMaxLength"/>
          <xsl:text>&gt;</xsl:text>
        </xsl:if>
        <xsl:text> </xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="getType">
          <xsl:with-param name="node" select="."/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:text> </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>=</xsl:text>

    <xsl:variable name="constValue">
      <xsl:call-template name="replace-string">
          <xsl:with-param name="text">
              <xsl:call-template name="replace-string">
                  <xsl:with-param name="text" select="@value"/>
                  <xsl:with-param name="search" select="'true'"/>
                  <xsl:with-param name="replace" select="'TRUE'"/>
              </xsl:call-template>
          </xsl:with-param>
          <xsl:with-param name="search" select="'false'"/>
          <xsl:with-param name="replace" select="'FALSE'"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:value-of select="$constValue"/>
    <xsl:text>;</xsl:text>
    <xsl:if test="./@resolveName">
      <xsl:text>//@resolve-name </xsl:text>
      <xsl:value-of select="./@resolveName"/>
    </xsl:if>
    <xsl:text>&nl;</xsl:text>
  </xsl:template>
<!-- Include template -->
  <xsl:template match="include">
    <xsl:text>#include "</xsl:text>
    <xsl:value-of select="concat(substring-before(@file,'.xml'),'.idl')"/>
    <xsl:text>"&nl;</xsl:text>
  </xsl:template>

<!-- Valuetype template -->
  <xsl:template match="valuetype">
    <xsl:call-template name="checkDuplicateName">
      <xsl:with-param name="member" select="."/>
    </xsl:call-template>
    <xsl:text>&nl;&nl;</xsl:text>
    <xsl:call-template name="printIndent">
      <xsl:with-param name="ind" select="count(ancestor::*)"/>
    </xsl:call-template>
    <xsl:if test="./@typeModifier='custom'">  
      <xsl:text>custom </xsl:text>
    </xsl:if>
    <xsl:if test="./@typeModifier='abstract'">  
      <xsl:text>abstract </xsl:text>
    </xsl:if>
    <xsl:if test="./@typeModifier='truncatable'">  
      <xsl:text>truncatable </xsl:text>
    </xsl:if>
    <xsl:text>valuetype </xsl:text> 
    <xsl:value-of select="./@name"/>
    <xsl:if test="./@baseClass">  
      <xsl:text> : </xsl:text>
      <xsl:value-of select="./@baseClass"/>
    </xsl:if>
    <xsl:text>{&nl;</xsl:text>
    <xsl:apply-templates/>
    <xsl:call-template name="printIndent">
      <xsl:with-param name="ind" select="count(ancestor::*)"/>
    </xsl:call-template><xsl:text>};&nl;</xsl:text>

    <xsl:if test="./@topLevel">
      <xsl:text>//@top-level </xsl:text>
      <xsl:value-of select="./@topLevel"/>
    </xsl:if>
    <xsl:text>&nl;</xsl:text>
    <xsl:if test="./@extensibility">
      <xsl:text>//@Extensibility </xsl:text>
      <xsl:choose>
          <xsl:when test="./@extensibility = 'extensible'">
              <xsl:text>EXTENSIBLE_EXTENSIBILITY</xsl:text>
          </xsl:when>
          <xsl:when test="./@extensibility = 'mutable'">
              <xsl:text>MUTABLE_EXTENSIBILITY</xsl:text>
          </xsl:when>
          <xsl:otherwise>
              <xsl:text>FINAL_EXTENSIBILITY</xsl:text>
          </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
    <xsl:text>&nl;</xsl:text>
    
  </xsl:template>

<!-- Struct template -->
  <xsl:template match="struct">
    <xsl:text>&nl;&nl;</xsl:text>
    <xsl:call-template name="printIndent">
      <xsl:with-param name="ind" select="count(ancestor::*)"/>
    </xsl:call-template>
    <xsl:text>struct </xsl:text>
    <xsl:value-of select="./@name"/>
    <xsl:if test="./@baseType">  
      <xsl:text> : </xsl:text>
      <xsl:value-of select="./@baseType"/>
    </xsl:if>
    <xsl:text>{&nl;</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>};&nl;</xsl:text>
    <xsl:if test="./@topLevel">
      <xsl:text>//@top-level </xsl:text>
      <xsl:value-of select="./@topLevel"/>
    </xsl:if>
    <xsl:text>&nl;</xsl:text>
    <xsl:if test="./@extensibility">
      <xsl:text>//@Extensibility </xsl:text>
      <xsl:choose>
          <xsl:when test="./@extensibility = 'extensible'">
              <xsl:text>EXTENSIBLE_EXTENSIBILITY</xsl:text>
          </xsl:when>
          <xsl:when test="./@extensibility = 'mutable'">
              <xsl:text>MUTABLE_EXTENSIBILITY</xsl:text>
          </xsl:when>
          <xsl:otherwise>
              <xsl:text>FINAL_EXTENSIBILITY</xsl:text>
          </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
    <xsl:text>&nl;</xsl:text>
  </xsl:template>

<!-- Member template -->
  <xsl:template match="member">
    <xsl:call-template name="checkDuplicateName">
      <xsl:with-param name="member" select="."/>
    </xsl:call-template>
    <xsl:text>&indent;</xsl:text>
    <xsl:call-template name="printIndent">
      <xsl:with-param name="ind" select="count(ancestor::*)"/>
    </xsl:call-template>
    <xsl:if test="local-name(./..)='valuetype'">
      <xsl:call-template name="checkValuetypeMember">
        <xsl:with-param name="vmember" select="."/>
      </xsl:call-template>
      <xsl:value-of select="./@visibility"/>
      <xsl:text> </xsl:text>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="@sequenceMaxLength and @sequenceMaxLength!=''">
        <xsl:text>sequence&lt;</xsl:text>
        <xsl:call-template name="getType">
          <xsl:with-param name="node" select="."/>
        </xsl:call-template>
        <xsl:if test="@sequenceMaxLength!='-1'">
            <xsl:text>,</xsl:text>
            <xsl:value-of select="@sequenceMaxLength"/>
        </xsl:if>
        <xsl:text>&gt;</xsl:text>
        <xsl:if test="@pointer='true' or @pointer='1'">
          <xsl:text> *</xsl:text>
        </xsl:if>
        <xsl:text> </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:apply-templates select="@arrayDimensions"/>
      </xsl:when>
      <xsl:when test="@type='string'">
        <xsl:text>string</xsl:text>
        <xsl:if test="@stringMaxLength and @stringMaxLength!='' and @stringMaxLength!='-1'">
          <xsl:text>&lt;</xsl:text>
          <xsl:value-of select="@stringMaxLength"/>
          <xsl:text>&gt;</xsl:text>
        </xsl:if>
        <xsl:if test="@pointer='true' or @pointer='1'">
          <xsl:text> *</xsl:text>
        </xsl:if>
        <xsl:text> </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:apply-templates select="@arrayDimensions"/>
      </xsl:when>
      <xsl:when test="@type='wstring'">
        <xsl:text>wstring</xsl:text>
        <xsl:if test="@stringMaxLength and @stringMaxLength!='' and @stringMaxLength!='-1'">
          <xsl:text>&lt;</xsl:text>
          <xsl:value-of select="@stringMaxLength"/>
          <xsl:text>&gt;</xsl:text>
        </xsl:if>
        <xsl:if test="@pointer='true' or @pointer='1'">
          <xsl:text> *</xsl:text>
        </xsl:if>
        <xsl:text> </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:apply-templates select="@arrayDimensions"/>
      </xsl:when>
      <xsl:when test="not(@sequenceMaxLength and @sequenceMaxLength!='')">
        <xsl:call-template name="getType">
          <xsl:with-param name="node" select="."/>
        </xsl:call-template>
        <xsl:if test="@pointer='true' or @pointer='1'">
          <xsl:text> *</xsl:text>
        </xsl:if>
        <xsl:text> </xsl:text>
        <xsl:value-of select="./@name"/>
        <xsl:if test="@bitField">
          <xsl:text> : </xsl:text>
          <xsl:value-of select="@bitField"/>
        </xsl:if>
        <xsl:apply-templates select="@arrayDimensions"/>
      </xsl:when>
    </xsl:choose>
    <xsl:text>; </xsl:text>
    <xsl:if test="./@resolveName">
      <xsl:text>//@resolve-name </xsl:text>
      <xsl:value-of select="./@resolveName"/>
      <xsl:text>&nl;</xsl:text>
    </xsl:if>
    <xsl:if test="./@key and (./@key='1' or ./@key='true')">
      <xsl:text>//@key  </xsl:text>
      <xsl:text>&nl;</xsl:text>
    </xsl:if>
    <xsl:if test="./@id">
      <xsl:text>//@ID </xsl:text>
      <xsl:value-of select="./@id"/>
      <xsl:text>&nl;</xsl:text>
    </xsl:if>
    <xsl:if test="./@optional">
      <xsl:text>//@Optional </xsl:text>
      <xsl:if test="./@optional='false'">
        <!-- No need to print 'true' after @Optional -->
        <xsl:text>false</xsl:text>
      </xsl:if>
      <xsl:text>&nl;</xsl:text>
    </xsl:if>
    <xsl:text>&nl;</xsl:text>
  </xsl:template>


  <xsl:template name="copy" match="directive">
    <!--<xsl:if test="not(@kind='key' or @kind='resolveName')">-->
      <xsl:text>//@</xsl:text>
      <xsl:choose>
        <xsl:when test="@kind='copyC'">
          <xsl:value-of select="'copy-c'"/>
        </xsl:when>
        <xsl:when test="@kind='copyJava'">
          <xsl:value-of select="'copy-java'"/>
        </xsl:when>
        <xsl:when test="@kind='copyJavaBegin'">
          <xsl:value-of select="'copy-java-begin'"/>
        </xsl:when>
        <xsl:when test="@kind='copyDeclaration'">
          <xsl:value-of select="'copy-declaration'"/>
        </xsl:when>
        <xsl:when test="@kind='copyJavaDeclaration'">
          <xsl:value-of select="'copy-java-declaration'"/>
        </xsl:when>
        <xsl:when test="@kind='copyJavaDeclarationBegin'">
          <xsl:value-of select="'copy-java-declaration-begin'"/>
        </xsl:when>
        <xsl:when test="@kind='copyCDeclaration'">
          <xsl:value-of select="'copy-c-declaration'"/>
        </xsl:when>
        <xsl:when test="@kind='copyCppcli'">
          <xsl:value-of select="'copy-cppcli'"/>
        </xsl:when>
        <xsl:when test="@kind='copyCppcliDeclaration'">
          <xsl:value-of select="'copy-cppcli-declaration'"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="./@kind"/>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:text> </xsl:text>
      <xsl:value-of select="."/>
      <xsl:text>&nl;</xsl:text>
    <!--</xsl:if>-->
  </xsl:template>

<!-- Union template -->
  <xsl:template match="union">
    <xsl:call-template name="checkDuplicateName">
      <xsl:with-param name="member" select="."/>
    </xsl:call-template>
        <xsl:text>&nl;&nl;</xsl:text>
    <xsl:call-template name="printIndent">
      <xsl:with-param name="ind" select="count(ancestor::*)"/>
    </xsl:call-template>
    <xsl:text>union </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text> switch (</xsl:text>
    <xsl:call-template name="getType">
      <xsl:with-param name="node" select="./discriminator"/>
    </xsl:call-template>
    <xsl:text>){&nl;</xsl:text>

    <xsl:for-each select="case">
      <xsl:for-each select="./caseDiscriminator">
        <xsl:if test="not(@value='default')">
          <xsl:text>case </xsl:text>
        </xsl:if>
        <xsl:variable name="caseValue">
          <xsl:call-template name="replace-string">
              <xsl:with-param name="text">
                  <xsl:call-template name="replace-string">
                      <xsl:with-param name="text" select="@value"/>
                      <xsl:with-param name="search" select="'true'"/>
                      <xsl:with-param name="replace" select="'TRUE'"/>
                  </xsl:call-template>
              </xsl:with-param>
              <xsl:with-param name="search" select="'false'"/>
              <xsl:with-param name="replace" select="'FALSE'"/>
          </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="$caseValue"/>
        <xsl:text>:&nl;</xsl:text>
      </xsl:for-each>
      <xsl:for-each select="member">
        <xsl:apply-templates select="."/>
      </xsl:for-each>
    </xsl:for-each>

    <xsl:call-template name="printIndent">
      <xsl:with-param name="ind" select="count(ancestor::*)"/>
    </xsl:call-template>
    <xsl:text>};</xsl:text>
    <xsl:if test="./@topLevel">
      <xsl:text>//@top-level </xsl:text>
      <xsl:value-of select="./@topLevel"/>
    </xsl:if>
    <xsl:text>&nl;</xsl:text>
    <xsl:if test="./@extensibility">
      <xsl:text>//@Extensibility </xsl:text>
      <xsl:choose>
          <xsl:when test="./@extensibility = 'extensible'">
              <xsl:text>EXTENSIBLE_EXTENSIBILITY</xsl:text>
          </xsl:when>
          <xsl:when test="./@extensibility = 'mutable'">
              <xsl:text>MUTABLE_EXTENSIBILITY</xsl:text>
          </xsl:when>
          <xsl:otherwise>
              <xsl:text>FINAL_EXTENSIBILITY</xsl:text>
          </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
    <xsl:text>&nl;</xsl:text>
  </xsl:template>

<!-- Cardinality template  -->
  <xsl:template name="printCardinality" match="@arrayDimensions">
      <xsl:call-template name="extractCardinalityElement">
        <xsl:with-param name="list" select="normalize-space(.)"/>
      </xsl:call-template>
  </xsl:template>

  <xsl:template name="extractCardinalityElement">
    <xsl:param name="list"/>
      <xsl:if test="$list!=''">
        <xsl:text>[</xsl:text>
          <xsl:choose>
            <xsl:when test="contains($list,',')">
              <xsl:value-of select="substring-before($list,',')"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="$list"/>
            </xsl:otherwise>
          </xsl:choose>
        <xsl:text>]</xsl:text>
        <xsl:call-template name="extractCardinalityElement">
          <xsl:with-param name="list" select="substring-after($list,',')"/>
        </xsl:call-template>
      </xsl:if>
  </xsl:template>

<!-- Module template -->
  <xsl:template match="module">
    <xsl:text>&nl;&nl;module </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>{&nl;</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>&nl;};&nl;</xsl:text>
  </xsl:template>

<!-- Enum template -->
  <xsl:template match="enum">
    <xsl:text>&nl;&nl;</xsl:text>
    <xsl:call-template name="printIndent">
      <xsl:with-param name="ind" select="count(ancestor::*)"/>
    </xsl:call-template>
    <xsl:text>enum </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>{&nl;</xsl:text>
    <xsl:for-each select="enumerator">
      <xsl:apply-templates select="."/>
      <xsl:if test="position() &lt; last()">
        <xsl:text>,</xsl:text>
      </xsl:if>
      <xsl:text>&nl;</xsl:text>
    </xsl:for-each>
    <xsl:call-template name="printIndent">
      <xsl:with-param name="ind" select="count(ancestor::*)"/>
    </xsl:call-template>
    <xsl:text>};&nl;</xsl:text>
    <xsl:if test="./@extensibility">
      <xsl:text>//@Extensibility </xsl:text>
      <xsl:choose>
          <xsl:when test="./@extensibility = 'extensible'">
              <xsl:text>EXTENSIBLE_EXTENSIBILITY</xsl:text>
          </xsl:when>
          <xsl:when test="./@extensibility = 'mutable'">
              <xsl:text>MUTABLE_EXTENSIBILITY</xsl:text>
          </xsl:when>
          <xsl:otherwise>
              <xsl:text>FINAL_EXTENSIBILITY</xsl:text>
          </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
    <xsl:text>&nl;</xsl:text>
    <xsl:if test="./@bitBound and ./@bitBound != 32">
      <xsl:text>//@BitBound </xsl:text>
      <xsl:value-of select="./@bitBound"/>
    </xsl:if>
  </xsl:template>

<!-- Bitset template -->
  <xsl:template match="bitset">
    <xsl:text>&nl;&nl;</xsl:text>
    <xsl:call-template name="printIndent">
      <xsl:with-param name="ind" select="count(ancestor::*)"/>
    </xsl:call-template>
    <xsl:text>enum </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>{&nl;</xsl:text>
    <xsl:for-each select="flag">
      <xsl:apply-templates select="."/>
      <xsl:if test="position() &lt; last()">
        <xsl:text>,</xsl:text>
      </xsl:if>
      <xsl:text>&nl;</xsl:text>
    </xsl:for-each>
    <xsl:call-template name="printIndent">
      <xsl:with-param name="ind" select="count(ancestor::*)"/>
    </xsl:call-template>
    <xsl:text>};&nl;</xsl:text>
    <xsl:text>//@BitSet&nl;</xsl:text>
    <xsl:if test="./@bitBound">
      <xsl:text>//@BitBound </xsl:text>
      <xsl:value-of select="./@bitBound"/>
    </xsl:if>
  </xsl:template>

<!-- Enumerator template -->
  <xsl:template match="enumerator|flag">
    <xsl:call-template name="printIndent">
      <xsl:with-param name="ind" select="count(ancestor::*)"/>
    </xsl:call-template>
    <xsl:value-of select="@name"/>
    <xsl:if test="@value">
      <xsl:text> = </xsl:text>
      <xsl:value-of select="@value"/>
    </xsl:if>
  </xsl:template>

<!-- Typedef template -->
  <xsl:template match="typedef">
    <xsl:text>typedef </xsl:text>
    <xsl:choose>
      <xsl:when test="@sequenceMaxLength and @sequenceMaxLength!=''">
        <xsl:text>sequence&lt;</xsl:text>
        <xsl:call-template name="getType">
          <xsl:with-param name="node" select="."/>
        </xsl:call-template>
<!--        <xsl:if test="@maxLength and @maxLength!=''">
            <xsl:text>,</xsl:text>
            <xsl:value-of select="@maxLength"/>
        </xsl:if>-->
        <xsl:if test="@sequenceMaxLength!='-1'">
            <xsl:text>,</xsl:text>
            <xsl:value-of select="@sequenceMaxLength"/>
        </xsl:if>
        <xsl:text>&gt;</xsl:text>
        <xsl:if test="@pointer='true' or @pointer='1'">
          <xsl:text> *</xsl:text>
        </xsl:if>
        <xsl:text> </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:apply-templates select="@arrayDimensions"/>
      </xsl:when>
      <xsl:when test="@type='string'">
        <xsl:text>string</xsl:text>
        <xsl:if test="@stringMaxLength and @stringMaxLength!='' and @stringMaxLength!='-1'">
          <xsl:text> &lt;</xsl:text>
          <xsl:value-of select="@stringMaxLength"/>
          <xsl:text>&gt; </xsl:text>
        </xsl:if>
        <xsl:if test="@pointer='true' or @pointer='1'">
          <xsl:text> *</xsl:text>
        </xsl:if>
        <xsl:text> </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:apply-templates select="@arrayDimensions"/>
      </xsl:when>
      <xsl:when test="@type='wstring'">
        <xsl:text>wstring</xsl:text>
        <xsl:if test="@stringMaxLength and @stringMaxLength!='' and @stringMaxLength!='-1'">
          <xsl:text> &lt;</xsl:text>
          <xsl:value-of select="@stringMaxLength"/>
          <xsl:text>&gt; </xsl:text>
        </xsl:if>
        <xsl:if test="@pointer='true' or @pointer='1'">
          <xsl:text> *</xsl:text>
        </xsl:if>
        <xsl:text> </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:apply-templates select="@arrayDimensions"/>
      </xsl:when>
      <xsl:when test="not(@sequenceMaxLength and @sequenceMaxLength!='')">
        <xsl:call-template name="getType">
          <xsl:with-param name="node" select="."/>
        </xsl:call-template>
        <xsl:if test="@pointer='true' or @pointer='1'">
          <xsl:text> *</xsl:text>
        </xsl:if>
        <xsl:text> </xsl:text>
        <xsl:value-of select="./@name"/>
        <xsl:if test="@bitField">
          <xsl:text> : </xsl:text>
          <xsl:value-of select="@bitField"/>
        </xsl:if>
        <xsl:apply-templates select="@arrayDimensions"/>
      </xsl:when>
    </xsl:choose>
    <xsl:text>; </xsl:text>
    <xsl:if test="./@resolveName">
      <xsl:text>//@resolve-name </xsl:text>
      <xsl:value-of select="./@resolveName"/>
    </xsl:if>
    <xsl:if test="./@topLevel">
      <xsl:text>//@top-level </xsl:text>
      <xsl:value-of select="./@topLevel"/>
    </xsl:if>
    <xsl:text>&nl;</xsl:text>
  </xsl:template>

<!-- Forward template -->
  <xsl:template match="forward_dcl">
    <xsl:call-template name="printIndent">
      <xsl:with-param name="ind" select="count(ancestor::*)"/>
    </xsl:call-template>
    <xsl:value-of select="./@kind"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="./@name"/>
    <xsl:text>;</xsl:text>
    <xsl:text>&nl;</xsl:text>
  </xsl:template>

<!-- getType template
    	This template obtains the type from an abbreviated notation
        e.g. unsignedshort -> unsigned short
        In addition, gets non basic types.
		-->
  <xsl:template name="getType">
    <xsl:param name="node"/>
    <xsl:choose>
      <xsl:when test="$node[@type='unsignedShort']">
        <xsl:text>unsigned short</xsl:text>
      </xsl:when>
      <xsl:when test="$node[@type='unsignedLong']">
        <xsl:text>unsigned long</xsl:text>
      </xsl:when>
      <xsl:when test="$node[@type='unsignedLongLong']">
        <xsl:text>unsigned long long</xsl:text>
      </xsl:when>
      <xsl:when test="$node[@type='longLong']">
        <xsl:text>long long</xsl:text>
      </xsl:when>
      <xsl:when test="$node[@type='longDouble']">
        <xsl:text>long double</xsl:text>
      </xsl:when>
      <xsl:when test="$node[@type='nonBasic']">
        <xsl:value-of select="$node/@nonBasicTypeName"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$node/@type"/>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:if test="($node/@type='string' or 
                  $node/@type='wstring') and 
                  $node/@stringMaxLength  and
                  $node/@stringMaxLength!='' and
                  $node/@stringMaxLength!='-1'">
      <xsl:text> &lt;</xsl:text><xsl:value-of select="$node/@stringMaxLength"/>
      <xsl:text>&gt; </xsl:text>
    </xsl:if>
    <!--
    <xsl:if test="$node[@pointer='true' or @pointer='1'] and $node[not(@sequenceMaxLength and @sequenceMaxLength!='')]">
      <xsl:text> *</xsl:text>
    </xsl:if>
    -->
  </xsl:template>

  <!-- printIndent template 
	This template indentates the IDL code, according to the depth
	-->
  <xsl:template name="printIndent">
    <xsl:param name="ind"/>
    <xsl:for-each select="../node() [position() &lt; $ind]">
      <xsl:text>&indent;</xsl:text>
    </xsl:for-each>
  </xsl:template>

  <xsl:template name="checkDuplicateName">
    <xsl:param name="member"/>
    <xsl:variable name="memberName" select="$member/@name"/>
    <xsl:if test="preceding-sibling::*[@name=$memberName and local-name(.)!='forward_dcl']">
      <xsl:message> Error! <xsl:value-of select="name($member)"/> name 
      '<xsl:value-of select="$memberName"/>' previously defined</xsl:message>
    </xsl:if>
  </xsl:template>

  <xsl:template name="checkUnionMember">
    <xsl:param name="umember"/>
      <xsl:if test="not($umember/cases/case)">
        <xsl:message terminate="yes">The members of an union should have at least one case</xsl:message> 
      </xsl:if>
      <!-- <xsl:call-template name="checkNonStructMember">
        <xsl:with-param name="member" select="$umember"/>
      </xsl:call-template>-->
  </xsl:template>

  <xsl:template name="checkValuetypeMember">
    <xsl:param name="vmember"/>
      <xsl:if test="not($vmember/@visibility)">
        <xsl:message terminate="yes">
        A valuetype member must have visibility defined
        </xsl:message> 
      </xsl:if>
      <!-- <xsl:call-template name="checkNonStructMember">
        <xsl:with-param name="member" select="$vmember"/>
      </xsl:call-template>-->
  </xsl:template>

  <xsl:template name="checkNonStructMember">
    <xsl:param name="member"/>
      <xsl:if test="$member/@resolveName">
        <xsl:message terminate="no"> 
        Error!: In <xsl:value-of select="name($member/..)"/> 
        '<xsl:value-of select="$member/../@name"/>':No resolveName attribute allowed inside <xsl:value-of select="name($member/..)"/> members!
        </xsl:message>
      </xsl:if> 
  </xsl:template>
</xsl:transform>
