<?xml version="1.0"?>
<!--
   $Id: type.ads.xsl,v 1.3 2012/04/23 16:44:18 fernando Exp $

   (c) Copyright 2007, Real-Time Innovations, Inc.  All rights reserved.
   No duplications, whole or partial, manual or electronic, may be made
   without prior written permission.  Any such copies, or
   revisions thereof, must display this notice unaltered.
   This code contains trade secrets of Real-Time Innovations, Inc.

Modification history
 - - - - - - - - - -
10o,27aug10,fcs Fixed baseClass resolution in value types
10o,26aug10,eys Fixed value types, fixed union spacing
10o,24aug10,fcs Multidimensional array support in unions
10o,24aug10,fcs Multidimensional array support
10o,24aug10,fcs Added begin directive
10o,24aug10,fcs Fixed constant name resolution
10o,24aug10,fcs Fixed enumeration
10o,17jun08,fcs Group types into modules
10o,16jun08,fcs 06/16/08 Merge changes
10o,20nov07,fcs Union support based on C layout
10o,29nov07,fcs 11/29/07 Merge changes
10o,12nov07,fcs All the constants inside a module are stored in the
                same files
10o,09nov07,fcs Mark changes 11/12/07
10o,09nov07,fcs Mark changes 11/02/07
10o,25oct07,fcs Support for contained non-primitive types
10o,09jul07,fcs Second review changes
10o,07jul07,fcs Replaced Seq with _Seq
10o,07jul07,fcs Change sequence ads file name
10o,07jul07,fcs First review changes
10o,06jul07,rbw Consolidated initialize/finalize procedures;
                refactored sequence instantiation here;
                random fixes
10o,05jul07,fcs Fixed functions declaration
10o,05jul07,fcs Added pointer type for unions
10o,05jul07,fcs Support for unions
10o,05jul07,fcs Continue ADA migration
10o,03jul07,fcs Fixed const template
10o,03jul07,fcs Fixed obtainSourceFileName calls
10o,03jul07,rbw Generate code into multiple files
10o,03jul07,rbw Created based on C version
-->

<!DOCTYPE xsl:stylesheet [
<!ENTITY nl "&#xa;">                <!-- new line -->
<!ENTITY indent "   ">              <!-- indentation -->
<!ENTITY namespaceSeperator ".">    <!-- namespace separator -->
]>

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"
                xmlns:xalan = "http://xml.apache.org/xalan"
                xmlns:str="http://exslt.org/strings">

<xsl:include href="typeCommon.ada.xsl"/>

<xsl:output method="xml"/>

<xsl:variable name="sourcePreamble" select="$generationInfo/sourcePreamble[@kind = 'type-header']"/>

<xsl:template match="/">

    <xsl:variable name="sourceFile">
        <xsl:call-template name="lower-case">
            <xsl:with-param name="text" select="concat($idlFileBaseName,'_idl_file.ads')"/>
        </xsl:call-template>
    </xsl:variable>


    <xsl:if test="./specification/node()[name(.)='struct']|
                  ./specification/node()[name(.)='typedef']|
                  ./specification/node()[name(.)='enum']|
                  ./specification/node()[name(.)='const']">
        <file name="{$sourceFile}">
            <xsl:variable name="containerNamespace">
                <xsl:value-of select="concat($idlFileBaseName,'_IDL_File')"/>
            </xsl:variable>
    
            <xsl:call-template name="printAutoGeneratedWarning"/>
    
            <!-- Generate type declaration -->
            <xsl:text>with DDS;&nl;</xsl:text>

            <xsl:if test="./specification/node()[name(.)='struct']|
                          ./specification/node()[name(.)='typedef']|
                          ./specification/node()[name(.)='enum']">
                <xsl:text>with DDS.Sequences_Generic;&nl;&nl;</xsl:text>
            </xsl:if>
    
            <!-- Generate with clauses -->
            <xsl:call-template name="generateWithClauses">
                <xsl:with-param name="containerNamespace" select="$containerNamespace"/>
                <xsl:with-param name="moduleNode" select="./specification"/>
            </xsl:call-template>

            <xsl:apply-templates select="/specification/directive[@kind = 'copy-ada-begin']|
                                         /specification/directive[@kind = 'copy-ada-declaration-begin']"/>
    
            <xsl:value-of select="concat('package ',$containerNamespace,' is')"/>
            <xsl:text>&nl;&nl;</xsl:text>
    
            <xsl:apply-templates select="./specification/node()[
                                            name(.)!='module' and 
                                            not(name(.)='directive' and 
                                                (./@kind = 'copy-ada-begin' or 
                                                 ./@kind = 'copy-ada-declaration-begin'))]">
                <xsl:with-param name="containerNamespace" select="$containerNamespace"/>
            </xsl:apply-templates>
    
            <xsl:value-of select="concat('end ',$containerNamespace,';')"/>
            <xsl:text>&nl;</xsl:text>
        </file>
    </xsl:if>

    <xsl:for-each select="//module">
        <xsl:variable name="containerNamespace">
            <xsl:call-template name="getModulePath">
                <xsl:with-param name="moduleNode" select="."/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="sourceFile">
            <xsl:call-template name="obtainSourceFileName">
                <xsl:with-param name="containerNamespace"
                                select="$containerNamespace"/>
                <xsl:with-param name="typeName" select="''"/>
                <xsl:with-param name="fileExt" select="'ads'"/>
            </xsl:call-template>
        </xsl:variable>

        <file name="{$sourceFile}">
            <xsl:call-template name="printAutoGeneratedWarning"/>

            <!-- Generate type declaration -->
            <xsl:if test="./node()[name(.)='struct']|
                          ./node()[name(.)='typedef']|
                          ./node()[name(.)='enum']|
                          ./node()[name(.)='const']">
                <xsl:text>with DDS;&nl;</xsl:text>

                <xsl:if test="./node()[name(.)='struct']|
                              ./node()[name(.)='typedef']|
                              ./node()[name(.)='enum']">
                    <xsl:text>with DDS.Sequences_Generic;&nl;&nl;</xsl:text>
                </xsl:if>
            </xsl:if>

            <!-- Generate with clauses -->
            <xsl:call-template name="generateWithClauses">
                <xsl:with-param name="containerNamespace" select="$containerNamespace"/>
                <xsl:with-param name="moduleNode" select="."/>
            </xsl:call-template>

            <xsl:apply-templates select="/specification/directive[@kind = 'copy-ada-begin']|
                                         /specification/directive[@kind = 'copy-ada-declaration-begin']"/>

            <xsl:value-of select="concat('package ',$containerNamespace,' is')"/>
            <xsl:text>&nl;&nl;</xsl:text>

            <xsl:apply-templates select="./node()[name(.)!='module']">
                <xsl:with-param name="containerNamespace" select="$containerNamespace"/>
            </xsl:apply-templates>

            <xsl:value-of select="concat('end ',$containerNamespace,';')"/>
            <xsl:text>&nl;</xsl:text>
        </file>
    </xsl:for-each>
</xsl:template>

<!-- Include -->
<!-- TODO: How to resolve the include directive?
     RTIDDSGEN is generating full qualified references,
     do we need 'with clauses' if we use the full qualified name?
-->
<!--
#include "<xsl:value-of select="concat(substring-before(@file, '.idl'), '.h')"/>"
</xsl:template> -->

<!-- Constant declarations -->
<xsl:template match="const">
    <xsl:param name="containerNamespace"/>

<!--
    <xsl:if test="not(./following-sibling::const)">
        <xsl:for-each select="./preceding-sibling::const|.">
-->
            <xsl:variable name="nativeType">
                <xsl:call-template name="obtainNativeType">
                    <xsl:with-param name="idlType" select="@type"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:text>   </xsl:text>
            <xsl:choose>
                <xsl:when test="$nativeType='Standard.DDS.String'">
                    <xsl:value-of select="concat(@name,' : constant ',$nativeType,' := Standard.DDS.To_DDS_String (',@value,');')"/>
                </xsl:when>
        	<xsl:otherwise>
        	    <xsl:value-of select="concat(@name,' : constant ',$nativeType,' := ',@value,';')"/>
        	</xsl:otherwise>
            </xsl:choose>
            <xsl:text>&nl;</xsl:text>
<!--
        </xsl:for-each>
    </xsl:if>
-->
</xsl:template>

<!-- Typedef declarations -->
<xsl:template match="typedef">
    <xsl:param name="containerNamespace"/>

    <xsl:variable name="description">
        <xsl:call-template name="getMemberDescription">
            <xsl:with-param name="member" select="./member"/>
        </xsl:call-template>
    </xsl:variable>

    <xsl:variable name="descriptionNode" select="xalan:nodeset($description)/node()"/>

    <xsl:variable name="nativeType">
         <xsl:call-template name="obtainNativeType">
             <xsl:with-param name="idlType" select="$descriptionNode/@type"/>
         </xsl:call-template>
    </xsl:variable>

    <xsl:variable name="pointer">
        <xsl:if test="$descriptionNode/@pointer='yes'">*</xsl:if>
    </xsl:variable>

    <xsl:variable name="dimensions">
	<xsl:call-template name="obtainArrayDimensions">
            <xsl:with-param name="cardinality" select="member/cardinality"/>
        </xsl:call-template>
    </xsl:variable>

    <xsl:variable name="baseMemberKind">
        <xsl:call-template name="obtainBaseMemberKind">
            <xsl:with-param name="member" select="./member"/>
        </xsl:call-template>
    </xsl:variable>

    <xsl:variable name="generateCode">
        <xsl:call-template name="isNecessaryGenerateCode">
            <xsl:with-param name="typedefNode" select="."/>
        </xsl:call-template>
    </xsl:variable>

    <xsl:variable name="fullyQualifiedAdaStructName">
        <xsl:value-of select="concat($containerNamespace,'.',@name)"/>
    </xsl:variable>

    <xsl:variable name="fullyQualifiedCStructName" select="translate($fullyQualifiedAdaStructName,'.','_')"/>

    <xsl:value-of select="concat('   type ',@name,' is ')"/>

    <xsl:choose>
        <xsl:when test="$descriptionNode/@memberKind='arraySequence' or
                      $descriptionNode/@memberKind='array'">
            <xsl:text>array </xsl:text><xsl:value-of select="$dimensions"/>
            <xsl:text> of </xsl:text>
        </xsl:when>
        <xsl:otherwise>
            <xsl:text>new </xsl:text>
        </xsl:otherwise>
    </xsl:choose>

    <xsl:choose>
        <xsl:when test="($descriptionNode/@memberKind='sequence'
                        or $descriptionNode/@memberKind='arraySequence')
                        and $descriptionNode/@type='string'">
            <xsl:text>Standard.DDS.String_Seq.Sequence;</xsl:text>
        </xsl:when>
        <xsl:when test="($descriptionNode/@memberKind='sequence' or
                        $descriptionNode/@memberKind='arraySequence')
                        and $descriptionNode/@type='wstring'">
            <xsl:text>Standard.DDS.Wstring_Seq.Sequence;</xsl:text>
        </xsl:when>
        <xsl:when test="$descriptionNode/@memberKind='sequence' or
                        $descriptionNode/@memberKind='arraySequence'">
            <xsl:value-of select="concat($nativeType,'_Seq.Sequence;')"/>
        </xsl:when>
        <xsl:when test="$descriptionNode/@type='string'">
            <xsl:text>Standard.DDS.String;</xsl:text>
        </xsl:when>
        <xsl:when test="$descriptionNode/@type='wstring'">
            <xsl:text>Standard.DDS.Wide_String;</xsl:text>
        </xsl:when>
        <xsl:otherwise>
            <xsl:value-of select="concat($nativeType,';')"/>
        </xsl:otherwise>
    </xsl:choose>
    <xsl:text>&nl;&nl;</xsl:text>

    <xsl:text>&nl;</xsl:text>
    <xsl:text>   </xsl:text>
    <xsl:value-of select="concat('type ',@name,'_Access is access all ',@name,';')"/>
    <xsl:text>&nl;</xsl:text>

    <xsl:text>   type </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>_Array is array (Natural range &lt;&gt;) of aliased </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>;&nl;</xsl:text>
    <xsl:text>   pragma Convention (C, </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>_Array);&nl;&nl;</xsl:text>

    <xsl:if test="$typecode='yes'">
        <xsl:text>   function </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>_Get_TypeCode return Standard.DDS.TypeCode_Access;&nl;</xsl:text>
        <xsl:text>   pragma Import (C, </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>_Get_TypeCode, "</xsl:text>
        <xsl:value-of select="$fullyQualifiedCStructName"/>
          <xsl:text>_get_typecode");&nl;&nl;</xsl:text>
    </xsl:if>

    <xsl:if test="$descriptionNode/@memberKind='sequence' or
                  $descriptionNode/@memberKind='arraySequence' or
                  $generateCode='yes'">
        <!-- Initialize -->
        <xsl:text>   procedure Initialize (This : in out </xsl:text>
        <xsl:value-of select="@name"/><xsl:text>);&nl;</xsl:text>

        <!-- Finalize -->
        <xsl:text>   procedure Finalize (This : in out </xsl:text>
        <xsl:value-of select="@name"/><xsl:text>);&nl;</xsl:text>

        <!-- Copy -->
        <xsl:text>   procedure Copy (Dst : in out </xsl:text>
        <xsl:value-of select="@name"/><xsl:text>;&nl;</xsl:text>
        <xsl:text>                  Src : in </xsl:text>
        <xsl:value-of select="@name"/><xsl:text>);&nl;&nl;</xsl:text>

        <xsl:text>&nl;</xsl:text>
    </xsl:if>

    <xsl:if test="$descriptionNode/@memberKind='sequence' or
                  $descriptionNode/@memberKind='arraySequence' or
                  $generateCode='yes'">
        <xsl:call-template name="generateSequence">
            <xsl:with-param name="typePackage" select="$containerNamespace"/>
            <xsl:with-param name="typeName" select="@name"/>
        </xsl:call-template>
    </xsl:if>
</xsl:template>

<!-- Enum declarations -->
<!-- TODO: enum with ordinals -->
<xsl:template match="enum">
    <xsl:param name="containerNamespace"/>

    <xsl:variable name="fullyQualifiedAdaStructName">
        <xsl:value-of select="concat($containerNamespace,'.',@name)"/>
    </xsl:variable>

    <xsl:variable name="fullyQualifiedCStructName" select="translate($fullyQualifiedAdaStructName,'.','_')"/>

    <xsl:value-of select="concat('   type ',@name,' is (')"/>

    <xsl:for-each select="enumerator">
        <xsl:variable name="enumString">
            <xsl:value-of select="@name"/>
        </xsl:variable>
        <xsl:choose>
           <xsl:when test="position()=last()">
               <xsl:value-of select="$enumString"/>
           </xsl:when>
           <xsl:otherwise>
               <xsl:value-of select="$enumString"/>
               <xsl:text>, </xsl:text>
           </xsl:otherwise>
        </xsl:choose>
    </xsl:for-each>

    <xsl:text>);&nl;</xsl:text>
    <xsl:text>   pragma Convention (C, </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>);&nl;</xsl:text>

    <xsl:if test="./enumerator/@value">
        <xsl:value-of select="concat('   for ',@name,' use (')"/>

        <xsl:for-each select="enumerator">
            <xsl:variable name="enumString">
                <xsl:value-of select="@name"/>
                <xsl:text> => </xsl:text>
                <xsl:value-of select="@value"/>
            </xsl:variable>
            <xsl:choose>
               <xsl:when test="position()=last()">
                   <xsl:value-of select="$enumString"/>
               </xsl:when>
               <xsl:otherwise>
                   <xsl:value-of select="$enumString"/>
                   <xsl:text>, </xsl:text>
               </xsl:otherwise>
            </xsl:choose>
        </xsl:for-each>

        <xsl:text>);&nl;</xsl:text>
    </xsl:if>

    <xsl:text>&nl;</xsl:text>
    <xsl:value-of select="concat('   type ',@name,'_Access is access all ',@name,';')"/>
    <xsl:text>&nl;</xsl:text>

    <xsl:text>   type </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>_Array is array (Natural range &lt;&gt;) of aliased </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>;&nl;</xsl:text>
    <xsl:text>   pragma Convention (C, </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>_Array);&nl;&nl;</xsl:text>

    <xsl:if test="$typecode='yes'">
        <xsl:text>   function </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>_Get_TypeCode return Standard.DDS.TypeCode_Access;&nl;</xsl:text>
        <xsl:text>   pragma Import (C, </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>_Get_TypeCode, "</xsl:text>
        <xsl:value-of select="$fullyQualifiedCStructName"/>
          <xsl:text>_get_typecode");&nl;&nl;</xsl:text>
    </xsl:if>

    <!-- Initialize -->
    <xsl:text>   procedure Initialize (This : in out </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>);&nl;</xsl:text>

    <!-- Finalize -->
    <xsl:text>   procedure Finalize (This : in out </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>);&nl;</xsl:text>

    <!-- Copy -->
    <xsl:text>   procedure Copy (Dst : in out </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>;&nl;</xsl:text>
    <xsl:text>                   Src : in </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>);&nl;&nl;</xsl:text>

    <!-- Begin sequence source file -->
    <xsl:call-template name="generateSequence">
        <xsl:with-param name="typePackage" select="$containerNamespace"/>
        <xsl:with-param name="typeName" select="@name"/>
    </xsl:call-template>
</xsl:template>

<!-- Struct declarations -->
<xsl:template match="struct">
    <xsl:param name="containerNamespace"/>

    <xsl:variable name="fullyQualifiedAdaStructName">
        <xsl:value-of select="concat($containerNamespace,'.',@name)"/>
    </xsl:variable>

    <xsl:variable name="fullyQualifiedCStructName" select="translate($fullyQualifiedAdaStructName,'.','_')"/>

    <xsl:apply-templates mode="error-checking"/>

    <xsl:if test="./member/@bitField">
        <xsl:message terminate="no">
            <xsl:text> Error: error generating code for structure '</xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>'. Bitfields are not supported.</xsl:text>
        </xsl:message>
    </xsl:if>

    <!-- Typename -->
    <xsl:text>   </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>_TypeName : Standard.DDS.String := Standard.DDS.To_DDS_String  ("</xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>");&nl;&nl;</xsl:text>

    <xsl:for-each select="./member">
        <!-- If we have arrays with more than one dimension -->
        <xsl:if test="(count(./cardinality/dimension) &gt;= 2) or
                      (./cardinality and ./@maxLengthSequence)">
            <xsl:text>   type </xsl:text>
            <xsl:value-of select="../@name"/>
            <xsl:text>_</xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>_Array</xsl:text>
            <xsl:text> is array </xsl:text>

            <xsl:call-template name="obtainArrayDimensions">
                <xsl:with-param name="cardinality" select="./cardinality"/>
            </xsl:call-template>

            <xsl:text> of aliased </xsl:text>

            <xsl:call-template name="obtainNativeType">
                <xsl:with-param name="idlType" select="@type"/>
            </xsl:call-template>

            <xsl:if test="./cardinality and ./@maxLengthSequence">
                <xsl:text>_Seq.Sequence</xsl:text>
            </xsl:if>

            <xsl:text>;&nl;&nl;</xsl:text>
        </xsl:if>
    </xsl:for-each>

    <!-- TODO: anonymous arrays support -->
    <!-- you are not allowed to declare an array with an anonymous type within a record -->
    <xsl:if test="not(@kind) or (@kind != 'valuetype')">
        <!-- struct definition -->
        <xsl:value-of select="concat('   type ',@name,' is record')"/>
        <xsl:apply-templates mode="code-generation">
            <xsl:with-param name="generationMode" select="'structMember'"/>
        </xsl:apply-templates>
        <xsl:text>&nl;   end record;&nl;</xsl:text>
        <xsl:text>   pragma Convention (C, </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>);&nl;&nl;</xsl:text>
    </xsl:if>

    <xsl:if test="@kind='valuetype'">
        <!-- value type definition -->
        <xsl:if test="@baseClass!=''">
            <xsl:value-of select="concat('   type ',@name,' is record')"/>
            <xsl:text>&nl;</xsl:text>
            <xsl:value-of select="concat('    parent : ',@baseClass,';')"/>
        </xsl:if>
        <xsl:if test="@baseClass=''">
            <xsl:value-of select="concat('   type ',@name,' is record')"/>
        </xsl:if>
        <xsl:apply-templates mode="code-generation">
            <xsl:with-param name="generationMode" select="'structMember'"/>
        </xsl:apply-templates><xsl:text>&nl;</xsl:text>
        <xsl:text>&nl;   end record;&nl;&nl;</xsl:text>
        <xsl:text>   pragma Convention (C, </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>);&nl;&nl;</xsl:text>
    </xsl:if>

    <xsl:value-of select="concat('   type ',@name,'_Access is access all ',@name,';')"/>
    <xsl:text>&nl;</xsl:text>

    <xsl:text>   type </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>_Array is array (Natural range &lt;&gt;) of aliased </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>;&nl;</xsl:text>
    <xsl:text>   pragma Convention (C, </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>_Array);&nl;&nl;</xsl:text>

    <xsl:if test="$typecode='yes'">
        <xsl:text>   function </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>_Get_TypeCode return Standard.DDS.TypeCode_Access;&nl;</xsl:text>
        <xsl:text>   pragma Import (C, </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>_Get_TypeCode, "</xsl:text>
        <xsl:value-of select="$fullyQualifiedCStructName"/>
          <xsl:text>_get_typecode");&nl;&nl;</xsl:text>
    </xsl:if>

    <!-- Initialize -->
    <xsl:text>   procedure Initialize (This : in out </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>);&nl;</xsl:text>

    <!-- Finalize -->
    <xsl:text>   procedure Finalize (This : in out </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>);&nl;</xsl:text>

    <!-- Copy -->
    <xsl:text>   procedure Copy (Dst : in out </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>;&nl;</xsl:text>
    <xsl:text>                   Src : in </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>);&nl;&nl;</xsl:text>

    <!-- Begin sequence source file -->
    <xsl:call-template name="generateSequence">
        <xsl:with-param name="typePackage" select="$containerNamespace"/>
        <xsl:with-param name="typeName" select="@name"/>
    </xsl:call-template>

</xsl:template>

<!-- Union declarations -->
<xsl:template match="struct[@kind='union']">
    <xsl:param name="containerNamespace"/>

    <xsl:variable name="fullyQualifiedAdaStructName">
        <xsl:value-of select="concat($containerNamespace,'.',@name)"/>
    </xsl:variable>

    <xsl:variable name="fullyQualifiedCStructName" select="translate($fullyQualifiedAdaStructName,'.','_')"/>

    <xsl:apply-templates mode="error-checking"/>

    <!-- Typename -->
    <xsl:text>   </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>_TypeName : Standard.DDS.String := Standard.DDS.To_DDS_String ("</xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>");&nl;&nl;</xsl:text>

    <xsl:variable name="baseType">
        <xsl:if test="$optLevel = '0'">
            <xsl:value-of select="./discriminator/@type"/>
        </xsl:if>
        <xsl:if test="not($optLevel = '0')">
            <xsl:call-template name="getBaseType">
                <xsl:with-param name="member" select="./discriminator"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:variable>

    <xsl:variable name="baseNativeType">
        <xsl:call-template name="obtainNativeType">
            <xsl:with-param name="idlType" select="$baseType"/>
        </xsl:call-template>
    </xsl:variable>

    <xsl:for-each select="./member">
        <!-- If we have arrays with more than one dimension -->
        <xsl:if test="(count(./cardinality/dimension) &gt;= 2) or
                      (./cardinality and ./@maxLengthSequence)">
            <xsl:text>   type </xsl:text>
            <xsl:value-of select="../@name"/>
            <xsl:text>_</xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>_Array</xsl:text>
            <xsl:text> is array </xsl:text>

            <xsl:call-template name="obtainArrayDimensions">
                <xsl:with-param name="cardinality" select="./cardinality"/>
            </xsl:call-template>

            <xsl:text> of aliased </xsl:text>

            <xsl:call-template name="obtainNativeType">
                <xsl:with-param name="idlType" select="@type"/>
            </xsl:call-template>

            <xsl:if test="./cardinality and ./@maxLengthSequence">
                <xsl:text>_Seq.Sequence</xsl:text>
            </xsl:if>

            <xsl:text>;&nl;&nl;</xsl:text>
        </xsl:if>
    </xsl:for-each>

    <!-- union declaration -->
    <xsl:value-of select="concat('   type U_',@name,' is record')"/>
    <xsl:apply-templates mode="code-generation">
        <xsl:with-param name="generationMode" select="'structMember'"/>
    </xsl:apply-templates>
    <xsl:text>&nl;   end record;&nl;</xsl:text>
    <xsl:text>   pragma Convention (C, U_</xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>);&nl;&nl;</xsl:text>

    <xsl:value-of select="concat('   type ',@name,' is record')"/>
    <xsl:text>&nl;</xsl:text>
    <xsl:value-of select="concat('    d : ',$baseNativeType,';')"/>
    <xsl:text>&nl;</xsl:text>
    <xsl:value-of select="concat('    u : U_',@name,';')"/>
    <xsl:text>&nl;   end record;&nl;&nl;</xsl:text>
    <xsl:text>   pragma Convention (C, </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>);&nl;&nl;</xsl:text>

    <xsl:value-of select="concat('   type ',@name,'_Access is access all ',@name,';')"/>
    <xsl:text>&nl;</xsl:text>

    <xsl:text>   type </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>_Array is array (Natural range &lt;&gt;) of aliased </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>;&nl;</xsl:text>
    <xsl:text>   pragma Convention (C, </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>_Array);&nl;&nl;</xsl:text>

    <xsl:if test="$typecode='yes'">
        <xsl:text>   function </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>_Get_TypeCode return Standard.DDS.TypeCode_Access;&nl;</xsl:text>
        <xsl:text>   pragma Import (C, </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>_Get_TypeCode, "</xsl:text>
        <xsl:value-of select="$fullyQualifiedCStructName"/>
          <xsl:text>_get_typecode");&nl;&nl;</xsl:text>
    </xsl:if>

    <!-- Initialize -->
    <xsl:text>   procedure Initialize (This : in out </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>);&nl;</xsl:text>

    <!-- Finalize -->
    <xsl:text>   procedure Finalize (This : in out </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>);&nl;</xsl:text>

    <!-- Copy -->
    <xsl:text>   procedure Copy (Dst : in out </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>;&nl;</xsl:text>
    <xsl:text>                   Src : in </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>);&nl;&nl;</xsl:text>

    <!-- Begin sequence source file -->
    <xsl:call-template name="generateSequence">
        <xsl:with-param name="typePackage" select="$containerNamespace"/>
        <xsl:with-param name="typeName" select="@name"/>
    </xsl:call-template>

</xsl:template>

<!--
Sequence Generation
-->
<xsl:template name="generateSequence">
    <xsl:param name="typePackage"/>
    <xsl:param name="typeName"/>

    <!-- =================================================== -->
    <!--                                                     -->
    <!--                Sequence                             -->
    <!--                                                     -->
    <!-- =================================================== -->

    <!-- Package declaration -->
    <xsl:value-of select="concat('   package ',$typeName,'_Seq')"/>
    <xsl:text> is new Standard.DDS.Sequences_Generic&nl;</xsl:text>
    <xsl:text>   (</xsl:text>
    <xsl:value-of select="concat($typePackage, '.', $typeName)"/>
    <xsl:text>,&nl;    </xsl:text>
    <xsl:value-of select="concat($typePackage, '.', $typeName,'_Access')"/>
    <xsl:text>,&nl;    Natural</xsl:text>
    <xsl:text>,&nl;    1</xsl:text>
    <xsl:text>,&nl;    </xsl:text>
    <xsl:value-of select="concat($typePackage, '.', $typeName,'_Array')"/>
    <xsl:text>);&nl;&nl;</xsl:text>

</xsl:template>

<!--
Process directives
-->
<xsl:template match="directive[@kind = 'copy-declaration' or @kind = 'copy-ada-declaration' or @kind = 'copy-ada-declaration-begin']">
    <xsl:text>&nl;</xsl:text><xsl:value-of select="text()"/><xsl:text>&nl;</xsl:text>
</xsl:template>

<xsl:template match="directive[@kind = 'copy-declaration' or @kind = 'copy-ada-declaration' or @kind = 'copy-ada-declaration-begin']"
              mode="code-generation">
    <xsl:text>&nl;</xsl:text><xsl:value-of select="text()"/><xsl:text>&nl;</xsl:text>
</xsl:template>

<!--
Helper templates
-->
<xsl:template name="getAdaPackage">
    <xsl:param name="type"/>
    <xsl:param name="dot" select="0"/>

    <xsl:variable name="afterDotStr" select="substring-after($type,'.')"/>

    <xsl:if test="$afterDotStr != ''">
        <xsl:if test="$dot = 1">
            <xsl:text>.</xsl:text>
        </xsl:if>
        <xsl:value-of select="substring-before($type,'.')"/>
        <xsl:call-template name="getAdaPackage">
            <xsl:with-param name="type" select="$afterDotStr"/>
            <xsl:with-param name="dot" select="1"/>
        </xsl:call-template>
    </xsl:if>
</xsl:template>

<xsl:template name="isIdentifier">
    <xsl:param name="str"/>

    <xsl:choose>
        <xsl:when test="$str = 'TRUE'">false</xsl:when>
        <xsl:when test="$str = 'FALSE'">false</xsl:when>
        <xsl:when test="starts-with($str,'-')">false</xsl:when>
        <xsl:when test="starts-with($str,'+')">false</xsl:when>
        <xsl:when test="starts-with($str,0)">false</xsl:when>
        <xsl:when test="starts-with($str,1)">false</xsl:when>
        <xsl:when test="starts-with($str,2)">false</xsl:when>
        <xsl:when test="starts-with($str,3)">false</xsl:when>
        <xsl:when test="starts-with($str,4)">false</xsl:when>
        <xsl:when test="starts-with($str,5)">false</xsl:when>
        <xsl:when test="starts-with($str,6)">false</xsl:when>
        <xsl:when test="starts-with($str,7)">false</xsl:when>
        <xsl:when test="starts-with($str,8)">false</xsl:when>
        <xsl:when test="starts-with($str,9)">false</xsl:when>
        <xsl:otherwise>true</xsl:otherwise>
    </xsl:choose>
</xsl:template>

<xsl:template name="containsPackage">
    <xsl:param name="str1"/>
    <xsl:param name="str2"/>

    <xsl:for-each select="str:tokenize($str1,' ;|')">
        <xsl:if test="$str2 = .">yes</xsl:if>
    </xsl:for-each>
</xsl:template>

<xsl:template name="generateConstWithClauses">
    <xsl:param name="containerNamespace"/>
    <xsl:param name="const"/>
    <xsl:param name="previousPackages" select="''"/>

    <xsl:if test="not(contains($const/@value,'&quot;'))">
        <xsl:for-each select="str:tokenize($const/@value,' ()+-/*|&amp;&lt;&gt;%~^&quot;')">
            <xsl:variable name="constAdaPackage">
                <xsl:call-template name="getAdaPackage">
                    <xsl:with-param name="type" select="."/>
                </xsl:call-template>
            </xsl:variable>
    
            <xsl:variable name="identifier">
                <xsl:call-template name="isIdentifier">
                    <xsl:with-param name="str" select="$constAdaPackage"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:variable name="duplicate">
                <xsl:call-template name="containsPackage">
                    <xsl:with-param name="str1" select="$previousPackages"/>
                    <xsl:with-param name="str2" select="$constAdaPackage"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:if test="$constAdaPackage != '' and 
                          $identifier = 'true' and
                          not(contains($duplicate,'yes')) and
                          ($constAdaPackage != $containerNamespace)">
                <xsl:text>with </xsl:text>
                <xsl:value-of select="$constAdaPackage"/>
                <xsl:text>;&nl;</xsl:text>
            </xsl:if>
        </xsl:for-each>
    </xsl:if>
    
    <xsl:variable name="nextPackages">
        <xsl:if test="not(contains($const/@value,'&quot;'))">
            <xsl:for-each select="str:tokenize($const/@value,' ()+-/*|&amp;&lt;&gt;%~^&quot;')">
                <xsl:call-template name="getAdaPackage">
                    <xsl:with-param name="type" select="."/>
                </xsl:call-template>
                <xsl:text>|</xsl:text>
            </xsl:for-each>
        </xsl:if>
    </xsl:variable>

    <xsl:if test="$const/following-sibling::const">
        <xsl:call-template name="generateConstWithClauses">
            <xsl:with-param name="containerNamespace" select="$containerNamespace"/>
            <xsl:with-param name="const" select="$const/following-sibling::const[1]"/>
            <xsl:with-param name="previousPackages" select="concat($previousPackages,$nextPackages)"/>
        </xsl:call-template>
    </xsl:if>
</xsl:template>

<xsl:template name="generateValueTypeWithClauses">
    <xsl:param name="containerNamespace"/>
    <xsl:param name="valueType"/>
    <xsl:param name="previousPackages" select="''"/>

    <xsl:variable name="valueAdaPackage">
        <xsl:call-template name="getAdaPackage">
            <xsl:with-param name="type" select="$valueType/@baseClass"/>
        </xsl:call-template>
    </xsl:variable>

    <xsl:variable name="identifier">
        <xsl:call-template name="isIdentifier">
            <xsl:with-param name="str" select="$valueAdaPackage"/>
        </xsl:call-template>
    </xsl:variable>

    <xsl:variable name="duplicate">
        <xsl:call-template name="containsPackage">
            <xsl:with-param name="str1" select="$previousPackages"/>
            <xsl:with-param name="str2" select="$valueAdaPackage"/>
        </xsl:call-template>
    </xsl:variable>

    <xsl:if test="$valueAdaPackage != '' and 
                  $identifier = 'true' and
                  not(contains($duplicate,'yes')) and
                  ($valueAdaPackage != $containerNamespace)">
        <xsl:text>with </xsl:text>
        <xsl:value-of select="$valueAdaPackage"/>
        <xsl:text>;&nl;</xsl:text>
    </xsl:if>
    
    <xsl:if test="$valueType/following-sibling::struct[@kind='value' and @baseClass]">
        <xsl:call-template name="generateValueTypeWithClauses">
            <xsl:with-param name="containerNamespace" select="$containerNamespace"/>
            <xsl:with-param name="const" select="$valueType/following-sibling::struct[@kind='valuetype' and @baseClass][1]"/>
            <xsl:with-param name="previousPackages" select="concat($previousPackages,$valueAdaPackage)"/>
        </xsl:call-template>
    </xsl:if>
</xsl:template>

<!--
Generates the with clauses for a module
-->
<xsl:template name="generateWithClauses">
    <xsl:param name="containerNamespace"/>
    <xsl:param name="moduleNode"/>

    <xsl:variable name="constWithClauses">
        <xsl:call-template name="generateConstWithClauses">
            <xsl:with-param name="containerNamespace" select="$containerNamespace"/>
            <xsl:with-param name="const" select="$moduleNode/const[1]"/>
        </xsl:call-template>
    </xsl:variable>

    <xsl:value-of select="$constWithClauses"/>

    <xsl:variable name="valueWithClauses">
        <xsl:call-template name="generateValueTypeWithClauses">
            <xsl:with-param name="containerNamespace" select="$containerNamespace"/>
            <xsl:with-param name="valueType" select="$moduleNode/struct[@kind='valuetype' and @baseClass][1]"/>
            <xsl:with-param name="previousPackages" select="$constWithClauses"/>
        </xsl:call-template>
    </xsl:variable>

    <xsl:value-of select="$valueWithClauses"/>

    <xsl:for-each select="$moduleNode/typedef|$moduleNode/struct">
        <xsl:variable name="typePosition" select="position()"/>

        <xsl:for-each select="./discriminator|./member">
            <xsl:variable name="typeKind">
                <xsl:call-template name="obtainTypeKind">
                    <xsl:with-param name="member" select="."/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:variable name="position" select="position()"/>

            <xsl:variable name="typeAdaPackage">
                <xsl:call-template name="getAdaPackage">
                    <xsl:with-param name="type" select="@type"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:if test="$typeKind = 'user' and @type != 'string' and @type != 'wstring' and
                          $typeAdaPackage != $containerNamespace">
                <xsl:variable name="duplicate">

                    <xsl:variable name="duplicateConst">
                        <xsl:call-template name="containsPackage">
                            <xsl:with-param name="str1" select="$constWithClauses"/>
                            <xsl:with-param name="str2" select="$typeAdaPackage"/>
                        </xsl:call-template>
                    </xsl:variable>

                    <xsl:variable name="duplicateValue">
                        <xsl:call-template name="containsPackage">
                            <xsl:with-param name="str1" select="$valueWithClauses"/>
                            <xsl:with-param name="str2" select="$typeAdaPackage"/>
                        </xsl:call-template>
                    </xsl:variable>

                    <xsl:if test="contains($duplicateConst,'yes') or
                                  contains($duplicateValue,'yes')">
                        duplicate
                    </xsl:if>

                    <xsl:if test="not(contains($duplicateConst,'yes')) and 
                                  not(contains($duplicateValue,'yes'))">
                        <xsl:for-each select="../../typedef|../../struct">
                            <xsl:if test="position() &lt; $typePosition">
                                <xsl:for-each select="./member|./discriminator">
    
                                    <xsl:variable name="prevTypeAdaPackage">
                                        <xsl:call-template name="getAdaPackage">
                                            <xsl:with-param name="type" select="@type"/>
                                        </xsl:call-template>
                                    </xsl:variable>
    
                                    <xsl:if test="$prevTypeAdaPackage = $typeAdaPackage">
                                        duplicate
                                    </xsl:if>
                                </xsl:for-each>
                            </xsl:if>
    
                            <xsl:if test="position() = $typePosition">
                                <xsl:for-each select="./member|./discriminator">
    
                                    <xsl:if test="position() &lt; $position">
                                        <xsl:variable name="prevTypeAdaPackage">
                                            <xsl:call-template name="getAdaPackage">
                                                <xsl:with-param name="type" select="@type"/>
                                            </xsl:call-template>
                                        </xsl:variable>
    
                                        <xsl:if test="$prevTypeAdaPackage = $typeAdaPackage">
                                            duplicate
                                        </xsl:if>
                                    </xsl:if>
                                </xsl:for-each>
                            </xsl:if>
    
                        </xsl:for-each>
                    </xsl:if>
                </xsl:variable>

                <xsl:if test="not(contains($duplicate,'duplicate'))">
                    <xsl:text>with </xsl:text>
                    <xsl:value-of select="$typeAdaPackage"/>
                    <xsl:text>;&nl;</xsl:text>
                </xsl:if>
            </xsl:if>
        </xsl:for-each>
        <xsl:text>&nl;</xsl:text>
    </xsl:for-each>
</xsl:template>

<!--
-->
<xsl:template name="getModulePath">
    <xsl:param name="moduleNode"/>  <!-- may be a module node or the specification node (root) --> 

    <xsl:for-each select="$moduleNode/ancestor::module">
        <xsl:value-of select="concat(@name,'.')"/>
    </xsl:for-each>
    <xsl:value-of select="@name"/>

</xsl:template>

</xsl:stylesheet>
