<?xml version="1.0"?>
<!--
   $Id: typeSupport.adb.xsl,v 1.5 2011/12/04 01:50:15 fernando Exp $

   (c) Copyright 2007, Real-Time Innovations, Inc.  All rights reserved.
   No duplications, whole or partial, manual or electronic, may be made
   without prior written permission.  Any such copies, or
   revisions thereof, must display this notice unaltered.
   This code contains trade secrets of Real-Time Innovations, Inc.

Modification history
 - - - - - - - - - -
1.0ae,28apr11,kaj Fixed Bug #13946, adding api for read/take_instance_w_condition
10o,24aug10,fcs begin directive support
10o,19jul10,eys Updated to work with 4.5c
10o,17jun08,fcs Group types into modules
10o,16jun08,fcs 06/16/08 Merge changes
10o,29nov07,fcs 11/29/07 Merge changes
10o,09nov07,fcs Mark changes 11/02/07
10o,14aug07,fcs Fixed write and print functions
10o,09jul07,fcs Second review changes
10o,07jul07,fcs DataWriter/DataReader support
10o,07jul07,fcs TypeSupport changes
10o,06jul07,rbw Started filling in method implementations
10o,03jul07,rbw Generate code into multiple files
10o,03jul07,rbw Created based on C version
-->

<!DOCTYPE xsl:stylesheet [
<!ENTITY nl "&#xa;">                <!-- new line -->
<!ENTITY indent "    ">             <!-- indentation -->
<!ENTITY namespaceSeperator "_">    <!-- namespace separator -->
]>

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
		xmlns:xalan="http://xml.apache.org/xalan" version="1.0">

<xsl:include href="typeCommon.ada.xsl"/>

<xsl:output method="xml"/>

<xsl:variable name="sourcePreamble" select="$generationInfo/sourcePreamble[@kind = 'support-source']"/>

<xsl:template match="struct">
    <xsl:param name="containerNamespace"/>

    <xsl:variable name="newContainerNamespace">
        <xsl:if test="name(..) = 'specification'">
            <xsl:value-of select="concat($idlFileBaseName,'_IDL_File')"/>
        </xsl:if>
        <xsl:if test="name(..) = 'module'">
            <xsl:value-of select="$containerNamespace"/>
        </xsl:if>
    </xsl:variable>

    <xsl:variable name="typePackageName">
        <xsl:value-of select="$newContainerNamespace"/>
    </xsl:variable>

    <xsl:variable name="fullyQualifiedAdaTypeName" select="concat($typePackageName,'.',@name)"/>
    <xsl:variable name="fullyQualifiedCTypeName">
        <xsl:if test="name(..) = 'specification'">
            <xsl:value-of select="@name"/>
        </xsl:if>
        <xsl:if test="name(..) = 'module'">
            <xsl:value-of select="translate($fullyQualifiedAdaTypeName,'.','_')"/>
        </xsl:if>
    </xsl:variable>

    <xsl:variable name="topLevel">
        <xsl:call-template name="isTopLevelType">
            <xsl:with-param name="typeNode" select="."/>
        </xsl:call-template>
    </xsl:variable>
    <xsl:if test="$topLevel='yes'">

        <xsl:apply-templates mode="error-checking"/>

        <!-- Data Writer -->
        <xsl:variable name="sourceFile">
            <xsl:call-template name="obtainSourceFileName">
                <xsl:with-param name="containerNamespace"
                                select="$newContainerNamespace"/>
                <xsl:with-param name="typeName"
                                select="concat(@name, '_datawriter')"/>
                <xsl:with-param name="fileExt" select="'adb'"/>
            </xsl:call-template>
        </xsl:variable>

        <!-- =================================================== -->
        <!--                                                     -->
        <!--                DataWriter                           -->
        <!--                                                     -->
        <!-- =================================================== -->
        <file name="{$sourceFile}">
            <xsl:call-template name="printAutoGeneratedWarning"/>

            <!-- Dependencies -->
            <xsl:text>pragma Warnings (Off); --  Since this is autogenerated code.&nl;</xsl:text>
            <xsl:text>with System;&nl;&nl;</xsl:text>
            <xsl:text>with DDS.Publisher_Impl;&nl;&nl;</xsl:text>
            <xsl:text>with </xsl:text>
            <xsl:value-of select="$typePackageName"/>
            <xsl:text>; use </xsl:text>
            <xsl:value-of select="$typePackageName"/>
            <xsl:text>;&nl;</xsl:text>

            <xsl:apply-templates select="/specification/directive[@kind = 'copy-ada-begin']"/>

            <xsl:text>pragma Warnings (On);&nl;</xsl:text>

            <!-- Begin package body -->
            <xsl:text>package body </xsl:text>
            <xsl:value-of select="$fullyQualifiedAdaTypeName"/>
            <xsl:text>_DataWriter is&nl;&nl;</xsl:text>

            <!-- Register_Instance -->
            <xsl:text>   -----------------------&nl;</xsl:text>
            <xsl:text>   -- Register_Instance --&nl;</xsl:text>
            <xsl:text>   -----------------------&nl;&nl;</xsl:text>

            <xsl:text>   function Register_Instance&nl;</xsl:text>
            <xsl:text>     (This          : not null access Ref;</xsl:text>
            <xsl:text>      Instance_Data : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access)&nl;</xsl:text>
            <xsl:text>      return Standard.DDS.InstanceHandle_T&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This          : System.Address;&nl;</xsl:text>
            <xsl:text>         Instance_Data : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataWriter_register_instance");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      return Internal (This.GetInterface, Instance_Data);&nl;</xsl:text>
            <xsl:text>   end Register_Instance;&nl;&nl;</xsl:text>

            <!-- Register_Instance_W_Timestamp -->
            <xsl:text>   -----------------------------------&nl;</xsl:text>
            <xsl:text>   -- Register_Instance_W_Timestamp --&nl;</xsl:text>
            <xsl:text>   -----------------------------------&nl;&nl;</xsl:text>

            <xsl:text>   function Register_Instance_W_Timestamp&nl;</xsl:text>
            <xsl:text>     (This             : not null access Ref;</xsl:text>
            <xsl:text>      Instance_Data    : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>      Source_Timestamp : in Standard.DDS.Time_T)&nl;</xsl:text>
            <xsl:text>      return Standard.DDS.InstanceHandle_T&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This             : System.Address;&nl;</xsl:text>
            <xsl:text>         Instance_Data    : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>         Source_Timestamp : access constant Standard.DDS.Time_T)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataWriter_register_instance_w_timestamp");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      return Internal (This.GetInterface, Instance_Data, Source_Timestamp'Unrestricted_Access);&nl;</xsl:text>
            <xsl:text>   end Register_Instance_W_Timestamp;&nl;&nl;</xsl:text>

            <!-- Unregister_Instance -->
            <xsl:text>   -------------------------&nl;</xsl:text>
            <xsl:text>   -- Unregister_Instance --&nl;</xsl:text>
            <xsl:text>   -------------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Unregister_Instance&nl;</xsl:text>
            <xsl:text>     (This          : not null access Ref;</xsl:text>
            <xsl:text>      Instance_Data : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>      Handle        : in Standard.DDS.InstanceHandle_T)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This          : System.Address;&nl;</xsl:text>
            <xsl:text>         Instance_Data : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>         Handle        : in Standard.DDS.InstanceHandle_T)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataWriter_unregister_instance");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal (This.GetInterface, Instance_Data, Handle));&nl;</xsl:text>
            <xsl:text>   end Unregister_Instance;&nl;&nl;</xsl:text>

            <!-- Unregister_Instance_W_Timestamp -->
            <xsl:text>   -------------------------------------&nl;</xsl:text>
            <xsl:text>   -- Unregister_Instance_W_Timestamp --&nl;</xsl:text>
            <xsl:text>   -------------------------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Unregister_Instance_W_Timestamp&nl;</xsl:text>
            <xsl:text>     (This             : not null access Ref;</xsl:text>
            <xsl:text>      Instance_Data    : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>      Handle           : in Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>      Source_Timestamp : in Standard.DDS.Time_T)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This             : System.Address;&nl;</xsl:text>
            <xsl:text>         Instance_Data    : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>         Handle           : in Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>         Source_Timestamp : access constant Standard.DDS.Time_T)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataWriter_unregister_instance_w_timestamp");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal (This.GetInterface, Instance_Data, Handle, Source_Timestamp'Unrestricted_Access));&nl;</xsl:text>
            <xsl:text>   end Unregister_Instance_W_Timestamp;&nl;&nl;</xsl:text>

            <!-- Write -->
            <xsl:text>   -----------&nl;</xsl:text>
            <xsl:text>   -- Write --&nl;</xsl:text>
            <xsl:text>   -----------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Write&nl;</xsl:text>
            <xsl:text>     (This          : not null access Ref;</xsl:text>
            <xsl:text>      Instance_Data : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>      Handle        : in Standard.DDS.InstanceHandle_T_Access)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This          : System.Address;&nl;</xsl:text>
            <xsl:text>         Instance_Data : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>         Handle        : in Standard.DDS.InstanceHandle_T_Access)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataWriter_write");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception (Internal (This.GetInterface, Instance_Data, Handle));&nl;</xsl:text>
            <xsl:text>   end Write;&nl;&nl;</xsl:text>

            <!-- Write_W_Timestamp -->
            <xsl:text>   -----------------------&nl;</xsl:text>
            <xsl:text>   -- Write_W_Timestamp --&nl;</xsl:text>
            <xsl:text>   -----------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Write_W_Timestamp&nl;</xsl:text>
            <xsl:text>     (This             : not null access Ref;</xsl:text>
            <xsl:text>      Instance_Data    : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>      Handle           : in Standard.DDS.InstanceHandle_T_Access;&nl;</xsl:text>
            <xsl:text>      Source_Timestamp : in Standard.DDS.Time_T)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This             : System.Address;&nl;</xsl:text>
            <xsl:text>         Instance_Data    : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>         Handle           : in Standard.DDS.InstanceHandle_T_Access;&nl;</xsl:text>
            <xsl:text>         Source_Timestamp : access constant Standard.DDS.Time_T)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataWriter_write_w_timestamp");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception (Internal (This.GetInterface, Instance_Data, Handle, Source_Timestamp'Unrestricted_Access));&nl;</xsl:text>
            <xsl:text>   end Write_W_Timestamp;&nl;&nl;</xsl:text>

            <!-- Dispose -->
            <xsl:text>   -------------&nl;</xsl:text>
            <xsl:text>   -- Dispose --&nl;</xsl:text>
            <xsl:text>   -------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Dispose&nl;</xsl:text>
            <xsl:text>     (This            : not null access Ref;</xsl:text>
            <xsl:text>      Instance_Data   : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>      Instance_Handle : in Standard.DDS.InstanceHandle_T)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This          : System.Address;&nl;</xsl:text>
            <xsl:text>         Instance_Data : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>         Handle        : in Standard.DDS.InstanceHandle_T)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataWriter_dispose");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception (Internal (This.GetInterface, Instance_Data, Instance_Handle));&nl;</xsl:text>
            <xsl:text>   end Dispose;&nl;&nl;</xsl:text>

            <!-- Dispose_W_Timestamp -->
            <xsl:text>   -------------------------&nl;</xsl:text>
            <xsl:text>   -- Dispose_W_Timestamp --&nl;</xsl:text>
            <xsl:text>   -------------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Dispose_W_Timestamp&nl;</xsl:text>
            <xsl:text>     (This             : not null access Ref;</xsl:text>
            <xsl:text>      Instance_Data    : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>      Instance_Handle  : in Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>      Source_Timestamp : in Standard.DDS.Time_T)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This             : System.Address;&nl;</xsl:text>
            <xsl:text>         Instance_Data    : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>         Handle           : in Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>         Source_Timestamp : access constant Standard.DDS.Time_T)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataWriter_dispose_w_timestamp");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal&nl;</xsl:text>
            <xsl:text>           (This.GetInterface, Instance_Data, Instance_Handle, Source_Timestamp'Unrestricted_Access));&nl;</xsl:text>
            <xsl:text>   end Dispose_W_Timestamp;&nl;&nl;</xsl:text>

            <!-- Get_Key_Value -->
            <xsl:text>   -------------------&nl;</xsl:text>
            <xsl:text>   -- Get_Key_Value --&nl;</xsl:text>
            <xsl:text>   -------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Get_Key_Value&nl;</xsl:text>
            <xsl:text>     (This       : not null access Ref;</xsl:text>
            <xsl:text>      Key_Holder : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>      Handle     : in Standard.DDS.InstanceHandle_T)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This       : System.Address;&nl;</xsl:text>
            <xsl:text>         Key_Holder : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>         Handle     : in Standard.DDS.InstanceHandle_T)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataWriter_get_key_value");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal&nl;</xsl:text>
            <xsl:text>           (This.GetInterface,&nl;</xsl:text>
            <xsl:text>            Key_Holder,&nl;</xsl:text>
            <xsl:text>            Handle));&nl;</xsl:text>
            <xsl:text>   end Get_Key_Value;&nl;&nl;</xsl:text>

            <!-- Lookup_Instance -->
            <xsl:text>   ---------------------&nl;</xsl:text>
            <xsl:text>   -- Lookup_Instance --&nl;</xsl:text>
            <xsl:text>   ---------------------&nl;&nl;</xsl:text>

            <xsl:text>   function Lookup_Instance&nl;</xsl:text>
            <xsl:text>     (This       : not null access Ref;</xsl:text>
            <xsl:text>      Key_Holder : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access) return Standard.DDS.InstanceHandle_T&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This       : System.Address;&nl;</xsl:text>
            <xsl:text>         Key_Holder : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataWriter_lookup_instance");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      return Internal (This.GetInterface, Key_Holder);&nl;</xsl:text>
            <xsl:text>   end Lookup_Instance;&nl;&nl;</xsl:text>

            <!-- Internal -->
            <xsl:text>   function CreateTypedI return Standard.DDS.DataWriter.Ref_Access is&nl;</xsl:text>
            <xsl:text>      S_Access : Ref_Access;&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      S_Access := new Ref;&nl;</xsl:text>
            <xsl:text>      return Standard.DDS.DataWriter.Ref_Access (S_Access);&nl;</xsl:text>
            <xsl:text>   end CreateTypedI;&nl;&nl;</xsl:text>

            <xsl:text>   procedure DestroyTypedI (Writer : in out Standard.DDS.DataWriter.Ref_Access) is&nl;</xsl:text>
            <xsl:text>      W_Impl : Standard.DDS.DataWriter_Impl.Ref_Access :=&nl;</xsl:text>
            <xsl:text>        Standard.DDS.DataWriter_Impl.Ref_Access (Writer);&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.DataWriter_Impl.Free (W_Impl);&nl;</xsl:text>
            <xsl:text>      Writer := null;&nl;</xsl:text>
            <xsl:text>   end DestroyTypedI;&nl;&nl;</xsl:text>

            <!-- End package body -->
            <xsl:text>begin&nl;</xsl:text>
            <xsl:text>   null;&nl;</xsl:text>
            <xsl:text>end </xsl:text>
            <xsl:value-of select="$fullyQualifiedAdaTypeName"/>
            <xsl:text>_DataWriter;&nl;</xsl:text>
        </file>

        <!-- =================================================== -->
        <!--                                                     -->
        <!--                DataReader                           -->
        <!--                                                     -->
        <!-- =================================================== -->
        <xsl:variable name="sourceFile">
            <xsl:call-template name="obtainSourceFileName">
                <xsl:with-param name="containerNamespace"
                                select="$newContainerNamespace"/>
                <xsl:with-param name="typeName"
                                select="concat(@name, '_datareader')"/>
                <xsl:with-param name="fileExt" select="'adb'"/>
            </xsl:call-template>
        </xsl:variable>

        <file name="{$sourceFile}">
            <xsl:call-template name="printAutoGeneratedWarning"/>

            <!-- Dependencies -->
            <xsl:text>pragma Warnings (Off); --  Since this is autogenerated code.&nl;</xsl:text>
            <xsl:text>with System;&nl;&nl;</xsl:text>
            <xsl:text>with DDS.ReadCondition_Impl;&nl;&nl;</xsl:text>
            <xsl:text>with </xsl:text>
            <xsl:value-of select="$typePackageName"/>
            <xsl:text>; use </xsl:text>
            <xsl:value-of select="$typePackageName"/>
            <xsl:text>;&nl;</xsl:text>

            <xsl:apply-templates select="/specification/directive[@kind = 'copy-ada-begin']"/>

            <xsl:text>pragma Warnings (On);&nl;</xsl:text>

            <!-- Begin package body -->
            <xsl:text>package body </xsl:text>
            <xsl:value-of select="$fullyQualifiedAdaTypeName"/>
            <xsl:text>_DataReader is&nl;&nl;</xsl:text>

            <!-- Read -->
            <xsl:text>   ----------&nl;</xsl:text>
            <xsl:text>   -- Read --&nl;</xsl:text>
            <xsl:text>   ----------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Read&nl;</xsl:text>
            <xsl:text>     (This            : not null access Ref;&nl;</xsl:text>
            <xsl:text>      Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>      Sample_States   : in Standard.DDS.SampleStateMask := Standard.DDS.ANY_SAMPLE_STATE;&nl;</xsl:text>
            <xsl:text>      View_States     : in Standard.DDS.ViewStateMask := Standard.DDS.ANY_VIEW_STATE;&nl;</xsl:text>
            <xsl:text>      Instance_States : in Standard.DDS.InstanceStateMask := Standard.DDS.ANY_INSTANCE_STATE)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This            : System.Address;&nl;</xsl:text>
            <xsl:text>         Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>         Sample_States   : in Standard.DDS.SampleStateMask := Standard.DDS.ANY_SAMPLE_STATE;&nl;</xsl:text>
            <xsl:text>         View_States     : in Standard.DDS.ViewStateMask := Standard.DDS.ANY_VIEW_STATE;&nl;</xsl:text>
            <xsl:text>         Instance_States : in Standard.DDS.InstanceStateMask := Standard.DDS.ANY_INSTANCE_STATE)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataReader_read");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal&nl;</xsl:text>
            <xsl:text>           (This.GetInterface,&nl;</xsl:text>
            <xsl:text>            Received_Data,&nl;</xsl:text>
            <xsl:text>            Info_Seq,&nl;</xsl:text>
            <xsl:text>            Max_Samples,&nl;</xsl:text>
            <xsl:text>            Sample_States,&nl;</xsl:text>
            <xsl:text>            View_States,&nl;</xsl:text>
            <xsl:text>            Instance_States));&nl;</xsl:text>
            <xsl:text>   end Read;&nl;&nl;</xsl:text>

            <!-- Take -->
            <xsl:text>   ----------&nl;</xsl:text>
            <xsl:text>   -- Take --&nl;</xsl:text>
            <xsl:text>   ----------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Take&nl;</xsl:text>
            <xsl:text>     (This            : not null access Ref;&nl;</xsl:text>
            <xsl:text>      Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>      Sample_States   : in Standard.DDS.SampleStateMask := Standard.DDS.ANY_SAMPLE_STATE;&nl;</xsl:text>
            <xsl:text>      View_States     : in Standard.DDS.ViewStateMask := Standard.DDS.ANY_VIEW_STATE;&nl;</xsl:text>
            <xsl:text>      Instance_States : in Standard.DDS.InstanceStateMask := Standard.DDS.ANY_INSTANCE_STATE)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This            : System.Address;&nl;</xsl:text>
            <xsl:text>         Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>         Sample_States   : in Standard.DDS.SampleStateMask := Standard.DDS.ANY_SAMPLE_STATE;&nl;</xsl:text>
            <xsl:text>         View_States     : in Standard.DDS.ViewStateMask := Standard.DDS.ANY_VIEW_STATE;&nl;</xsl:text>
            <xsl:text>         Instance_States : in Standard.DDS.InstanceStateMask := Standard.DDS.ANY_INSTANCE_STATE)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataReader_take");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal&nl;</xsl:text>
            <xsl:text>           (This.GetInterface,&nl;</xsl:text>
            <xsl:text>            Received_Data,&nl;</xsl:text>
            <xsl:text>            Info_Seq,&nl;</xsl:text>
            <xsl:text>            Max_Samples,&nl;</xsl:text>
            <xsl:text>            Sample_States,&nl;</xsl:text>
            <xsl:text>            View_States,&nl;</xsl:text>
            <xsl:text>            Instance_States));&nl;</xsl:text>
            <xsl:text>   end Take;&nl;&nl;</xsl:text>

            <!-- Read_W_Condition -->
            <xsl:text>   ----------------------&nl;</xsl:text>
            <xsl:text>   -- Read_W_Condition --&nl;</xsl:text>
            <xsl:text>   ----------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Read_W_Condition&nl;</xsl:text>
            <xsl:text>     (This          : not null access Ref;&nl;</xsl:text>
            <xsl:text>      Received_Data : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Info_Seq      : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Max_Samples   : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>      Condition     : access Standard.DDS.ReadCondition.Ref'Class)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This          : System.Address;&nl;</xsl:text>
            <xsl:text>         Received_Data : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Info_Seq      : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Max_Samples   : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>         Condition     : System.Address)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataReader_read_w_condition");&nl;&nl;</xsl:text>
            <xsl:text>      C : constant Standard.DDS.ReadCondition_Impl.Ref_Access :=&nl;</xsl:text>
            <xsl:text>        Standard.DDS.ReadCondition_Impl.Ref_Access (Condition);&nl;&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal&nl;</xsl:text>
            <xsl:text>           (This.GetInterface,&nl;</xsl:text>
            <xsl:text>            Received_Data,&nl;</xsl:text>
            <xsl:text>            Info_Seq,&nl;</xsl:text>
            <xsl:text>            Max_Samples,&nl;</xsl:text>
            <xsl:text>            C.GetInterface));&nl;</xsl:text>
            <xsl:text>   end Read_W_Condition;&nl;&nl;</xsl:text>

            <!-- Take_W_Condition -->
            <xsl:text>   ----------------------&nl;</xsl:text>
            <xsl:text>   -- Take_W_Condition --&nl;</xsl:text>
            <xsl:text>   ----------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Take_W_Condition&nl;</xsl:text>
            <xsl:text>     (This          : not null access Ref;&nl;</xsl:text>
            <xsl:text>      Received_Data : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Info_Seq      : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Max_Samples   : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>      Condition     : access Standard.DDS.ReadCondition.Ref'Class)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This          : System.Address;&nl;</xsl:text>
            <xsl:text>         Received_Data : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Info_Seq      : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Max_Samples   : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>         Condition     : System.Address)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataReader_take_w_condition");&nl;&nl;</xsl:text>
            <xsl:text>      C : constant Standard.DDS.ReadCondition_Impl.Ref_Access :=&nl;</xsl:text>
            <xsl:text>        Standard.DDS.ReadCondition_Impl.Ref_Access (Condition);&nl;&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal&nl;</xsl:text>
            <xsl:text>           (This.GetInterface,&nl;</xsl:text>
            <xsl:text>            Received_Data,&nl;</xsl:text>
            <xsl:text>            Info_Seq,&nl;</xsl:text>
            <xsl:text>            Max_Samples,&nl;</xsl:text>
            <xsl:text>            C.GetInterface));&nl;</xsl:text>
            <xsl:text>   end Take_W_Condition;&nl;&nl;</xsl:text>

            <!-- Read_Next_Sample -->
            <xsl:text>   ----------------------&nl;</xsl:text>
            <xsl:text>   -- Read_Next_Sample --&nl;</xsl:text>
            <xsl:text>   ----------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Read_Next_Sample&nl;</xsl:text>
            <xsl:text>     (This          : not null access Ref;&nl;</xsl:text>
            <xsl:text>      Received_Data : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>      Sample_Info   : not null access Standard.DDS.SampleInfo)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This          : System.Address;&nl;</xsl:text>
            <xsl:text>         Received_Data : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>         Sample_Info   : not null access Standard.DDS.SampleInfo)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataReader_read_next_sample");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal&nl;</xsl:text>
            <xsl:text>           (This.GetInterface,&nl;</xsl:text>
            <xsl:text>            Received_Data,&nl;</xsl:text>
            <xsl:text>            Sample_Info));&nl;</xsl:text>
            <xsl:text>   end Read_Next_Sample;&nl;&nl;</xsl:text>

            <!-- Take_Next_Sample -->
            <xsl:text>   ----------------------&nl;</xsl:text>
            <xsl:text>   -- Take_Next_Sample --&nl;</xsl:text>
            <xsl:text>   ----------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Take_Next_Sample&nl;</xsl:text>
            <xsl:text>     (This          : not null access Ref;&nl;</xsl:text>
            <xsl:text>      Received_Data : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>      Sample_Info   : not null access Standard.DDS.SampleInfo)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This          : System.Address;&nl;</xsl:text>
            <xsl:text>         Received_Data : not null </xsl:text><xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>         Sample_Info   : not null access Standard.DDS.SampleInfo)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataReader_take_next_sample");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal&nl;</xsl:text>
            <xsl:text>           (This.GetInterface,&nl;</xsl:text>
            <xsl:text>            Received_Data,&nl;</xsl:text>
            <xsl:text>            Sample_Info));&nl;</xsl:text>
            <xsl:text>   end Take_Next_Sample;&nl;&nl;</xsl:text>

            <!-- Read_Instance -->
            <xsl:text>   -------------------&nl;</xsl:text>
            <xsl:text>   -- Read_Instance --&nl;</xsl:text>
            <xsl:text>   -------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Read_Instance&nl;</xsl:text>
            <xsl:text>     (This            : not null access Ref;&nl;</xsl:text>
            <xsl:text>      Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>      A_Handle        : access constant Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>      Sample_States   : in Standard.DDS.SampleStateMask := Standard.DDS.ANY_SAMPLE_STATE;&nl;</xsl:text>
            <xsl:text>      View_States     : in Standard.DDS.ViewStateMask := Standard.DDS.ANY_VIEW_STATE;&nl;</xsl:text>
            <xsl:text>      Instance_States : in Standard.DDS.InstanceStateMask := Standard.DDS.ANY_INSTANCE_STATE)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This            : System.Address;&nl;</xsl:text>
            <xsl:text>         Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>         A_Handle        : access constant Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>         Sample_States   : in Standard.DDS.SampleStateMask := Standard.DDS.ANY_SAMPLE_STATE;&nl;</xsl:text>
            <xsl:text>         View_States     : in Standard.DDS.ViewStateMask := Standard.DDS.ANY_VIEW_STATE;&nl;</xsl:text>
            <xsl:text>         Instance_States : in Standard.DDS.InstanceStateMask := Standard.DDS.ANY_INSTANCE_STATE)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataReader_read_instance");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal&nl;</xsl:text>
            <xsl:text>           (This.GetInterface,&nl;</xsl:text>
            <xsl:text>            Received_Data,&nl;</xsl:text>
            <xsl:text>            Info_Seq,&nl;</xsl:text>
            <xsl:text>            Max_Samples,&nl;</xsl:text>
            <xsl:text>            A_Handle,&nl;</xsl:text>
            <xsl:text>            Sample_States,&nl;</xsl:text>
            <xsl:text>            View_States,&nl;</xsl:text>
            <xsl:text>            Instance_States));&nl;</xsl:text>
            <xsl:text>   end Read_Instance;&nl;&nl;</xsl:text>

            <!-- Take_Instance -->
            <xsl:text>   -------------------&nl;</xsl:text>
            <xsl:text>   -- Take_Instance --&nl;</xsl:text>
            <xsl:text>   -------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Take_Instance&nl;</xsl:text>
            <xsl:text>     (This            : not null access Ref;&nl;</xsl:text>
            <xsl:text>      Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>      A_Handle        : access constant Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>      Sample_States   : in Standard.DDS.SampleStateMask := Standard.DDS.ANY_SAMPLE_STATE;&nl;</xsl:text>
            <xsl:text>      View_States     : in Standard.DDS.ViewStateMask := Standard.DDS.ANY_VIEW_STATE;&nl;</xsl:text>
            <xsl:text>      Instance_States : in Standard.DDS.InstanceStateMask := Standard.DDS.ANY_INSTANCE_STATE)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This            : System.Address;&nl;</xsl:text>
            <xsl:text>         Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>         A_Handle        : access constant Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>         Sample_States   : in Standard.DDS.SampleStateMask := Standard.DDS.ANY_SAMPLE_STATE;&nl;</xsl:text>
            <xsl:text>         View_States     : in Standard.DDS.ViewStateMask := Standard.DDS.ANY_VIEW_STATE;&nl;</xsl:text>
            <xsl:text>         Instance_States : in Standard.DDS.InstanceStateMask := Standard.DDS.ANY_INSTANCE_STATE)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataReader_take_instance");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal&nl;</xsl:text>
            <xsl:text>           (This.GetInterface,&nl;</xsl:text>
            <xsl:text>            Received_Data,&nl;</xsl:text>
            <xsl:text>            Info_Seq,&nl;</xsl:text>
            <xsl:text>            Max_Samples,&nl;</xsl:text>
            <xsl:text>            A_Handle,&nl;</xsl:text>
            <xsl:text>            Sample_States,&nl;</xsl:text>
            <xsl:text>            View_States,&nl;</xsl:text>
            <xsl:text>            Instance_States));&nl;</xsl:text>
            <xsl:text>   end Take_Instance;&nl;&nl;</xsl:text>

            <!-- Read_Instance_W_Condition -->
            <xsl:text>   -------------------------------&nl;</xsl:text>
            <xsl:text>   -- Read_Instance_W_Condition --&nl;</xsl:text>
            <xsl:text>   -------------------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Read_Instance_W_Condition&nl;</xsl:text>
            <xsl:text>     (This            : not null access Ref;&nl;</xsl:text>
            <xsl:text>      Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>      Previous_Handle : access constant Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>      Condition       : Standard.DDS.ReadCondition.Ref_Access)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This            : System.Address;&nl;</xsl:text>
            <xsl:text>         Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>         Previous_Handle : access constant Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>         Condition       : System.Address)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataReader_read_instance_w_condition");&nl;&nl;</xsl:text>
            <xsl:text>      C : constant Standard.DDS.ReadCondition_Impl.Ref_Access :=&nl;</xsl:text>
            <xsl:text>        Standard.DDS.ReadCondition_Impl.Ref_Access (Condition);&nl;&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal&nl;</xsl:text>
            <xsl:text>           (This.GetInterface,&nl;</xsl:text>
            <xsl:text>            Received_Data,&nl;</xsl:text>
            <xsl:text>            Info_Seq,&nl;</xsl:text>
            <xsl:text>            Max_Samples,&nl;</xsl:text>
            <xsl:text>            Previous_Handle,&nl;</xsl:text>
            <xsl:text>            C.GetInterface));&nl;</xsl:text>
            <xsl:text>   end Read_Instance_W_Condition;&nl;&nl;</xsl:text>

            <!-- Take_Instance_W_Condition -->
            <xsl:text>   -------------------------------&nl;</xsl:text>
            <xsl:text>   -- Take_Instance_W_Condition --&nl;</xsl:text>
            <xsl:text>   -------------------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Take_Instance_W_Condition&nl;</xsl:text>
            <xsl:text>     (This            : not null access Ref;&nl;</xsl:text>
            <xsl:text>      Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>      Previous_Handle : access constant Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>      Condition       : Standard.DDS.ReadCondition.Ref_Access)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This            : System.Address;&nl;</xsl:text>
            <xsl:text>         Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>         Previous_Handle : access constant Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>         Condition       : System.Address)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataReader_take_instance_w_condition");&nl;&nl;</xsl:text>
            <xsl:text>      C : constant Standard.DDS.ReadCondition_Impl.Ref_Access :=&nl;</xsl:text>
            <xsl:text>        Standard.DDS.ReadCondition_Impl.Ref_Access (Condition);&nl;&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal&nl;</xsl:text>
            <xsl:text>           (This.GetInterface,&nl;</xsl:text>
            <xsl:text>            Received_Data,&nl;</xsl:text>
            <xsl:text>            Info_Seq,&nl;</xsl:text>
            <xsl:text>            Max_Samples,&nl;</xsl:text>
            <xsl:text>            Previous_Handle,&nl;</xsl:text>
            <xsl:text>            C.GetInterface));&nl;</xsl:text>
            <xsl:text>   end Take_Instance_W_Condition;&nl;&nl;</xsl:text>

            <!-- Read_Next_Instance -->
            <xsl:text>   ------------------------&nl;</xsl:text>
            <xsl:text>   -- Read_Next_Instance --&nl;</xsl:text>
            <xsl:text>   ------------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Read_Next_Instance&nl;</xsl:text>
            <xsl:text>     (This            : not null access Ref;&nl;</xsl:text>
            <xsl:text>      Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>      Previous_Handle : access constant Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>      Sample_States   : in Standard.DDS.SampleStateMask := Standard.DDS.ANY_SAMPLE_STATE;&nl;</xsl:text>
            <xsl:text>      View_States     : in Standard.DDS.ViewStateMask := Standard.DDS.ANY_VIEW_STATE;&nl;</xsl:text>
            <xsl:text>      Instance_States : in Standard.DDS.InstanceStateMask := Standard.DDS.ANY_INSTANCE_STATE)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This            : System.Address;&nl;</xsl:text>
            <xsl:text>         Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>         Previous_Handle : access constant Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>         Sample_States   : in Standard.DDS.SampleStateMask := Standard.DDS.ANY_SAMPLE_STATE;&nl;</xsl:text>
            <xsl:text>         View_States     : in Standard.DDS.ViewStateMask := Standard.DDS.ANY_VIEW_STATE;&nl;</xsl:text>
            <xsl:text>         Instance_States : in Standard.DDS.InstanceStateMask := Standard.DDS.ANY_INSTANCE_STATE)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataReader_read_next_instance");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal&nl;</xsl:text>
            <xsl:text>           (This.GetInterface,&nl;</xsl:text>
            <xsl:text>            Received_Data,&nl;</xsl:text>
            <xsl:text>            Info_Seq,&nl;</xsl:text>
            <xsl:text>            Max_Samples,&nl;</xsl:text>
            <xsl:text>            Previous_Handle,&nl;</xsl:text>
            <xsl:text>            Sample_States,&nl;</xsl:text>
            <xsl:text>            View_States,&nl;</xsl:text>
            <xsl:text>            Instance_States));&nl;</xsl:text>
            <xsl:text>   end Read_Next_Instance;&nl;&nl;</xsl:text>

            <!-- Take_Next_Instance -->
            <xsl:text>   ------------------------&nl;</xsl:text>
            <xsl:text>   -- Take_Next_Instance --&nl;</xsl:text>
            <xsl:text>   ------------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Take_Next_Instance&nl;</xsl:text>
            <xsl:text>     (This            : not null access Ref;&nl;</xsl:text>
            <xsl:text>      Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>      Previous_Handle : access constant Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>      Sample_States   : in Standard.DDS.SampleStateMask := Standard.DDS.ANY_SAMPLE_STATE;&nl;</xsl:text>
            <xsl:text>      View_States     : in Standard.DDS.ViewStateMask := Standard.DDS.ANY_VIEW_STATE;&nl;</xsl:text>
            <xsl:text>      Instance_States : in Standard.DDS.InstanceStateMask := Standard.DDS.ANY_INSTANCE_STATE)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This            : System.Address;&nl;</xsl:text>
            <xsl:text>         Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>         Previous_Handle : access constant Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>         Sample_States   : in Standard.DDS.SampleStateMask := Standard.DDS.ANY_SAMPLE_STATE;&nl;</xsl:text>
            <xsl:text>         View_States     : in Standard.DDS.ViewStateMask := Standard.DDS.ANY_VIEW_STATE;&nl;</xsl:text>
            <xsl:text>         Instance_States : in Standard.DDS.InstanceStateMask := Standard.DDS.ANY_INSTANCE_STATE)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataReader_take_next_instance");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal&nl;</xsl:text>
            <xsl:text>           (This.GetInterface,&nl;</xsl:text>
            <xsl:text>            Received_Data,&nl;</xsl:text>
            <xsl:text>            Info_Seq,&nl;</xsl:text>
            <xsl:text>            Max_Samples,&nl;</xsl:text>
            <xsl:text>            Previous_Handle,&nl;</xsl:text>
            <xsl:text>            Sample_States,&nl;</xsl:text>
            <xsl:text>            View_States,&nl;</xsl:text>
            <xsl:text>            Instance_States));&nl;</xsl:text>
            <xsl:text>   end Take_Next_Instance;&nl;&nl;</xsl:text>

            <!-- Read_Next_Instance_W_Condition -->
            <xsl:text>   ------------------------------------&nl;</xsl:text>
            <xsl:text>   -- Read_Next_Instance_W_Condition --&nl;</xsl:text>
            <xsl:text>   ------------------------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Read_Next_Instance_W_Condition&nl;</xsl:text>
            <xsl:text>     (This            : not null access Ref;&nl;</xsl:text>
            <xsl:text>      Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>      Previous_Handle : access constant Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>      Condition       : Standard.DDS.ReadCondition.Ref_Access)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This            : System.Address;&nl;</xsl:text>
            <xsl:text>         Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>         Previous_Handle : access constant Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>         Condition       : System.Address)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataReader_read_next_instance_w_condition");&nl;&nl;</xsl:text>
            <xsl:text>      C : constant Standard.DDS.ReadCondition_Impl.Ref_Access :=&nl;</xsl:text>
            <xsl:text>        Standard.DDS.ReadCondition_Impl.Ref_Access (Condition);&nl;&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal&nl;</xsl:text>
            <xsl:text>           (This.GetInterface,&nl;</xsl:text>
            <xsl:text>            Received_Data,&nl;</xsl:text>
            <xsl:text>            Info_Seq,&nl;</xsl:text>
            <xsl:text>            Max_Samples,&nl;</xsl:text>
            <xsl:text>            Previous_Handle,&nl;</xsl:text>
            <xsl:text>            C.GetInterface));&nl;</xsl:text>
            <xsl:text>   end Read_Next_Instance_W_Condition;&nl;&nl;</xsl:text>

            <!-- Take_Next_Instance_W_Condition -->
            <xsl:text>   ------------------------------------&nl;</xsl:text>
            <xsl:text>   -- Take_Next_Instance_W_Condition --&nl;</xsl:text>
            <xsl:text>   ------------------------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Take_Next_Instance_W_Condition&nl;</xsl:text>
            <xsl:text>     (This            : not null access Ref;&nl;</xsl:text>
            <xsl:text>      Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>      Previous_Handle : access constant Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>      Condition       : Standard.DDS.ReadCondition.Ref_Access)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This            : System.Address;&nl;</xsl:text>
            <xsl:text>         Received_Data   : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Info_Seq        : not null access Standard.DDS.SampleInfo_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Max_Samples     : in Standard.DDS.Long := Standard.DDS.LENGTH_UNLIMITED;&nl;</xsl:text>
            <xsl:text>         Previous_Handle : access constant Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>         Condition       : System.Address)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataReader_take_next_instance_w_condition");&nl;&nl;</xsl:text>
            <xsl:text>      C : constant Standard.DDS.ReadCondition_Impl.Ref_Access :=&nl;</xsl:text>
            <xsl:text>        Standard.DDS.ReadCondition_Impl.Ref_Access (Condition);&nl;&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal&nl;</xsl:text>
            <xsl:text>           (This.GetInterface,&nl;</xsl:text>
            <xsl:text>            Received_Data,&nl;</xsl:text>
            <xsl:text>            Info_Seq,&nl;</xsl:text>
            <xsl:text>            Max_Samples,&nl;</xsl:text>
            <xsl:text>            Previous_Handle,&nl;</xsl:text>
            <xsl:text>            C.GetInterface));&nl;</xsl:text>
            <xsl:text>   end Take_Next_Instance_W_Condition;&nl;&nl;</xsl:text>

            <!-- Get_Key_Value -->
            <xsl:text>   -------------------&nl;</xsl:text>
            <xsl:text>   -- Get_Key_Value --&nl;</xsl:text>
            <xsl:text>   -------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Get_Key_Value&nl;</xsl:text>
            <xsl:text>     (This       : not null access Ref;&nl;</xsl:text>
            <xsl:text>      Key_Holder : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>      Handle     : access constant Standard.DDS.InstanceHandle_T)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This       : System.Address;&nl;</xsl:text>
            <xsl:text>         Key_Holder : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>         Handle     : access constant Standard.DDS.InstanceHandle_T)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataReader_get_key_value");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal&nl;</xsl:text>
            <xsl:text>           (This.GetInterface,&nl;</xsl:text>
            <xsl:text>            Key_Holder,&nl;</xsl:text>
            <xsl:text>            Handle));&nl;</xsl:text>
            <xsl:text>   end Get_Key_Value;&nl;&nl;</xsl:text>

            <!-- Lookup_Instance -->
            <xsl:text>   ---------------------&nl;</xsl:text>
            <xsl:text>   -- Lookup_Instance --&nl;</xsl:text>
            <xsl:text>   ---------------------&nl;&nl;</xsl:text>

            <xsl:text>   function Lookup_Instance&nl;</xsl:text>
            <xsl:text>     (This       : not null access Ref;&nl;</xsl:text>
            <xsl:text>      Key_Holder : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access) return Standard.DDS.InstanceHandle_T&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This       : System.Address;&nl;</xsl:text>
            <xsl:text>         Key_Holder : not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.InstanceHandle_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataReader_lookup_instance");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      return Internal (This.GetInterface, Key_Holder);&nl;</xsl:text>
            <xsl:text>   end Lookup_Instance;&nl;&nl;</xsl:text>

            <!-- Return_Loan -->
            <xsl:text>   -----------------&nl;</xsl:text>
            <xsl:text>   -- Return_Loan --&nl;</xsl:text>
            <xsl:text>   -----------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Return_Loan&nl;</xsl:text>
            <xsl:text>     (This          : not null access Ref;&nl;</xsl:text>
            <xsl:text>      Received_Data : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>      Info_Seq      : not null access Standard.DDS.SampleInfo_Seq.Sequence)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (This          : System.Address;&nl;</xsl:text>
            <xsl:text>         Received_Data : not null access </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Seq.Sequence;&nl;</xsl:text>
            <xsl:text>         Info_Seq      : not null access Standard.DDS.SampleInfo_Seq.Sequence)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>DataReader_return_loan");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal&nl;</xsl:text>
            <xsl:text>           (This.GetInterface,&nl;</xsl:text>
            <xsl:text>            Received_Data,&nl;</xsl:text>
            <xsl:text>            Info_Seq));&nl;</xsl:text>
            <xsl:text>   end Return_Loan;&nl;&nl;</xsl:text>

            <!-- Internal -->
            <xsl:text>   function CreateTypedI return Standard.DDS.DataReader.Ref_Access is&nl;</xsl:text>
            <xsl:text>      S_Access : Ref_Access;&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      S_Access := new Ref;&nl;</xsl:text>
            <xsl:text>      return Standard.DDS.DataReader.Ref_Access (S_Access);&nl;</xsl:text>
            <xsl:text>   end CreateTypedI;&nl;&nl;</xsl:text>

            <xsl:text>   procedure DestroyTypedI (Reader : in out Standard.DDS.DataReader.Ref_Access) is&nl;</xsl:text>
            <xsl:text>      R_Impl : Standard.DDS.DataReader_Impl.Ref_Access :=&nl;</xsl:text>
            <xsl:text>        Standard.DDS.DataReader_Impl.Ref_Access (Reader);&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.DataReader_Impl.Free (R_Impl);&nl;</xsl:text>
            <xsl:text>      Reader := null;&nl;</xsl:text>
            <xsl:text>   end DestroyTypedI;&nl;&nl;</xsl:text>


            <!-- End package body -->

            <xsl:text>begin&nl;</xsl:text>
            <xsl:text>   null;&nl;</xsl:text>
            <xsl:text>end </xsl:text>
            <xsl:value-of select="$fullyQualifiedAdaTypeName"/>
            <xsl:text>_DataReader;&nl;</xsl:text>
        </file>

        <!-- =================================================== -->
        <!--                                                     -->
        <!--                TypeSupport                          -->
        <!--                                                     -->
        <!-- =================================================== -->
        <xsl:variable name="sourceFile">
            <xsl:call-template name="obtainSourceFileName">
                <xsl:with-param name="containerNamespace"
                                select="$newContainerNamespace"/>
                <xsl:with-param name="typeName"
                                select="concat(@name,'_typesupport')"/>
                <xsl:with-param name="fileExt" select="'adb'"/>
            </xsl:call-template>
        </xsl:variable>

        <file name="{$sourceFile}">
            <xsl:call-template name="printAutoGeneratedWarning"/>

            <!-- Dependencies -->
            <xsl:text>with System; use System;&nl;</xsl:text>
            <xsl:text>pragma Warnings (OFF);&nl;</xsl:text>
            <xsl:text>with Ada.Unchecked_Conversion;&nl;&nl;</xsl:text>
            <xsl:text>with NDDS.Low_Level.C_Domain_Impl;&nl;</xsl:text>
            <xsl:text>with NDDS.Low_Level.Pres.TypePlugin;&nl;</xsl:text>
            <xsl:text>with NDDS.Low_Level.OS_Api.Alignment_Impl;&nl;</xsl:text>
            <xsl:text>with Interfaces.C.Strings;&nl;</xsl:text>
            <xsl:text>with </xsl:text>
            <xsl:value-of select="$fullyQualifiedAdaTypeName"/>
            <xsl:text>_DataReader;&nl;</xsl:text>
            <xsl:text>with </xsl:text>
            <xsl:value-of select="$fullyQualifiedAdaTypeName"/>
            <xsl:text>_DataWriter;&nl;</xsl:text>
            <xsl:text>with DDS.DomainParticipant_Impl;&nl;</xsl:text>

            <xsl:apply-templates select="/specification/directive[@kind = 'copy-ada-begin']"/>

            <!-- Begin package body -->
            <xsl:text>package body </xsl:text>
            <xsl:value-of select="$fullyQualifiedAdaTypeName"/>
            <xsl:text>_TypeSupport is&nl;&nl;</xsl:text>

            <!-- Static Data -->
            <xsl:text>   use Standard.NDDS.Low_Level.C_Domain_Impl;&nl;</xsl:text>
            <xsl:text>   use Standard.NDDS.Low_Level.Pres.TypePlugin;&nl;&nl;</xsl:text>
            <xsl:text>   The_Instance : aliased Ref;&nl;</xsl:text>
            <xsl:text>   Instance_Ref : constant Standard.DDS.TypeSupport.Ref_Access := The_Instance'Access;&nl;&nl;</xsl:text>

            <!-- TypeSupport Object methods -->
            <xsl:text>   function Create_TypedDataReaderI&nl;</xsl:text>
            <xsl:text>     (Self : access Ref) return Standard.DDS.DataReader.Ref_Access is&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      return </xsl:text>
            <xsl:value-of select="$fullyQualifiedAdaTypeName"/>
            <xsl:text>_DataReader.CreateTypedI;&nl;</xsl:text>
            <xsl:text>   end  Create_TypedDataReaderI;&nl;&nl;</xsl:text>

            <xsl:text>   procedure Destroy_TypedDataReaderI&nl;</xsl:text>
            <xsl:text>     (Self   : access Ref;&nl;</xsl:text>
            <xsl:text>      Reader : in out Standard.DDS.DataReader.Ref_Access) is&nl;</xsl:text>
            <xsl:text>   begin&nl;   </xsl:text>
            <xsl:text>   </xsl:text>
            <xsl:value-of select="$fullyQualifiedAdaTypeName"/>
            <xsl:text>_DataReader.DestroyTypedI (Reader);&nl;</xsl:text>
            <xsl:text>   end  Destroy_TypedDataReaderI;&nl;&nl;</xsl:text>

            <xsl:text>   function Create_TypedDataWriterI&nl;</xsl:text>
            <xsl:text>     (Self : access Ref) return Standard.DDS.DataWriter.Ref_Access is&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      return </xsl:text>
            <xsl:value-of select="$fullyQualifiedAdaTypeName"/>
            <xsl:text>_DataWriter.CreateTypedI;&nl;</xsl:text>
            <xsl:text>   end  Create_TypedDataWriterI;&nl;&nl;</xsl:text>

            <xsl:text>   procedure Destroy_TypedDataWriterI&nl;</xsl:text>
            <xsl:text>     (Self   : access Ref;&nl;</xsl:text>
            <xsl:text>      Writer : in out Standard.DDS.DataWriter.Ref_Access) is&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Writer := null;&nl;</xsl:text>
            <xsl:text>   end Destroy_TypedDataWriterI;&nl;&nl;</xsl:text>

            <xsl:text>   function Get_Native_Typesupport_Ptr&nl;</xsl:text>
            <xsl:text>     (DeleteInstance : Standard.DDS.Boolean)&nl;</xsl:text>
            <xsl:text>     return System.Address;&nl;</xsl:text>
            <xsl:text>   pragma Import (C, Get_Native_Typesupport_Ptr, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>TypeSupport_get_or_delete_instanceI");&nl;&nl;</xsl:text>

            <xsl:text>   function R_To_A is new Ada.Unchecked_Conversion&nl;</xsl:text>
            <xsl:text>     (Source => Ref_Access,&nl;</xsl:text>
            <xsl:text>      Target => System.Address);&nl;&nl;</xsl:text>

            <xsl:text>   procedure Set_User_Data&nl;</xsl:text>
            <xsl:text>     (Self : System.Address; User_Data : System.Address);&nl;</xsl:text>
            <xsl:text>   pragma Import (C, Set_User_Data,</xsl:text>
            <xsl:text>                  "DDS_DataTypeUtility_set_user_dataI");&nl;&nl;</xsl:text>

            <!-- Register_Type -->
            <xsl:text>   -------------------&nl;</xsl:text>
            <xsl:text>   -- Register_Type --&nl;</xsl:text>
            <xsl:text>   -------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Register_Type&nl;</xsl:text>
            <xsl:text>     (Participant : not null access Standard.DDS.DomainParticipant.Ref'Class;&nl;</xsl:text>
            <xsl:text>      Type_Name   : in Standard.DDS.String) is&nl;&nl;</xsl:text>
            <xsl:text>      P : constant Standard.DDS.DomainParticipant_Impl.Ref_Access :=&nl;</xsl:text>
            <xsl:text>            Standard.DDS.DomainParticipant_Impl.Ref_Access (Participant);&nl;&nl;</xsl:text>
            <xsl:text>      function Internal&nl;</xsl:text>
            <xsl:text>        (Participant : System.Address;&nl;</xsl:text>
            <xsl:text>         Type_Name   : in Interfaces.C.Strings.chars_ptr)&nl;</xsl:text>
            <xsl:text>         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>TypeSupport_register_type");&nl;&nl;</xsl:text>
            <xsl:text>      C_DataTypeUtility_Ptr : access Standard.NDDS.Low_Level.Pres.TypePlugin.PRESTypePlugin;&nl;</xsl:text>
            <xsl:text>      type TempT is access all Standard.NDDS.Low_Level.OS_Api.Alignment_Impl.RTIOsapiAlignmentUnionOfAllDataTypes;&nl;</xsl:text>
            <xsl:text>      function convert is new Ada.Unchecked_Conversion (Standard.DDS.TypeSupport.Ref_Access, TempT);&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal (P.GetInterface, Type_Name.data),&nl;</xsl:text>
            <xsl:text>         "unable to register type");&nl;&nl;</xsl:text>
            <xsl:text>      C_DataTypeUtility_Ptr :=&nl;</xsl:text>
            <xsl:text>        DDS_DomainParticipant_Get_Type_PluginI&nl;</xsl:text>
            <xsl:text>          (Participant.getInterface,&nl;</xsl:text>
            <xsl:text>           Type_Name.data);&nl;</xsl:text>
            <xsl:text>      C_DataTypeUtility_Ptr.u_userBuffer := convert (Instance_Ref).all'Unrestricted_Access;&nl;</xsl:text>
            <xsl:text>   end Register_Type;&nl;&nl;</xsl:text>

            <!-- Get_Type_Name -->
            <xsl:text>   -------------------&nl;</xsl:text>
            <xsl:text>   -- Get_Type_Name --&nl;</xsl:text>
            <xsl:text>   -------------------&nl;&nl;</xsl:text>

            <xsl:text>   function Get_Type_Name&nl;</xsl:text>
            <xsl:text>     return Standard.DDS.String is&nl;</xsl:text>
            <xsl:text>      function Internal return Interfaces.C.Strings.chars_ptr;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>TypeSupport_get_type_name");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      return ret : Standard.DDS.String do&nl;</xsl:text>
            <xsl:text>         ret.data := Internal;&nl;</xsl:text>
            <xsl:text>      end return;&nl;</xsl:text>
            <xsl:text>   end Get_Type_Name;&nl;&nl;</xsl:text>

            <!-- Create_Data -->
            <xsl:text>   -----------------&nl;</xsl:text>
            <xsl:text>   -- Create_Data --&nl;</xsl:text>
            <xsl:text>   -----------------&nl;&nl;</xsl:text>

            <xsl:text>   function Create_Data&nl;</xsl:text>
            <xsl:text>     (AllocatePointers : in Boolean := True)&nl;</xsl:text>
            <xsl:text>      return not null </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal (AllocatePointers : in Boolean)&nl;</xsl:text>
            <xsl:text>                         return </xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>TypeSupport_create_data_ex");&nl;</xsl:text>
            <xsl:text>      Ret : </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Ret := Internal (AllocatePointers);&nl;</xsl:text>
            <xsl:text>      if Ret = null then&nl;</xsl:text>
            <xsl:text>         raise Storage_Error with "Unable to create " &amp; "</xsl:text>
            <xsl:value-of select="@name"/><xsl:text>";&nl;</xsl:text>
            <xsl:text>      else&nl;</xsl:text>
            <xsl:text>         return Ret;&nl;</xsl:text>
            <xsl:text>      end if;&nl;</xsl:text>
            <xsl:text>   end Create_Data;&nl;&nl;</xsl:text>

            <!-- Delete_Data -->
            <xsl:text>   -----------------&nl;</xsl:text>
            <xsl:text>   -- Delete_Data --&nl;</xsl:text>
            <xsl:text>   -----------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Delete_Data&nl;</xsl:text>
            <xsl:text>     (A_Data         : in out </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>      DeletePointers : in Boolean := True)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal (A_Data         : in </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>_Access;&nl;</xsl:text>
            <xsl:text>                         DeletePointers : in Boolean := True)&nl;</xsl:text>
            <xsl:text>                         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>TypeSupport_delete_data_ex");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal (A_Data, DeletePointers),&nl;</xsl:text>
            <xsl:text>         "Unable to delete data");&nl;</xsl:text>
            <xsl:text>      A_Data := null;&nl;</xsl:text>
            <xsl:text>   end Delete_Data;&nl;&nl;</xsl:text>

            <!-- Print Data -->
            <xsl:text>   ----------------&nl;</xsl:text>
            <xsl:text>   -- Print_Data --&nl;</xsl:text>
            <xsl:text>   ----------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Print_Data&nl;</xsl:text>
            <xsl:text>     (A_Data : not null access constant </xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      procedure Internal (A_Data : not null access constant </xsl:text>
            <xsl:value-of select="@name"/><xsl:text>);&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>TypeSupport_print_data");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Internal (A_Data);&nl;</xsl:text>
            <xsl:text>   end Print_Data;&nl;&nl;</xsl:text>

            <!-- Copy Data -->
            <xsl:text>   ---------------&nl;</xsl:text>
            <xsl:text>   -- Copy_Data --&nl;</xsl:text>
            <xsl:text>   ---------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Copy_Data&nl;</xsl:text>
            <xsl:text>     (Dest   : not null access </xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>;&nl;</xsl:text>
            <xsl:text>      Source : not null access constant </xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal (Dest   : not null access </xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>;&nl;</xsl:text>
            <xsl:text>                         Source : not null access constant </xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>)&nl;</xsl:text>
            <xsl:text>                         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>TypeSupport_copy_data");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal (Dest, Source),&nl;</xsl:text>
            <xsl:text>         "Unable to copy data");&nl;</xsl:text>
            <xsl:text>   end Copy_Data;&nl;&nl;</xsl:text>

            <!-- Initialize_Data -->
            <xsl:text>   ---------------------&nl;</xsl:text>
            <xsl:text>   -- Initialize_Data --&nl;</xsl:text>
            <xsl:text>   ---------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Initialize_Data&nl;</xsl:text>
            <xsl:text>     (Dest             : not null access </xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>;&nl;</xsl:text>
            <xsl:text>      AllocatePointers : in Boolean := True)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal (Dest             : not null access </xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>;&nl;</xsl:text>
            <xsl:text>                         AllocatePointers : in Boolean := True)&nl;</xsl:text>
            <xsl:text>                         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>TypeSupport_initialize_data_ex");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal (Dest, AllocatePointers),&nl;</xsl:text>
            <xsl:text>         "Unable to initialize data");&nl;</xsl:text>
            <xsl:text>   end Initialize_Data;&nl;&nl;</xsl:text>

            <!-- Finalize_Data -->
            <xsl:text>   -------------------&nl;</xsl:text>
            <xsl:text>   -- Finalize_Data --&nl;</xsl:text>
            <xsl:text>   -------------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Finalize_Data&nl;</xsl:text>
            <xsl:text>     (Dest           : not null access </xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>;&nl;</xsl:text>
            <xsl:text>      DeletePointers : in Boolean := True)&nl;</xsl:text>
            <xsl:text>   is&nl;</xsl:text>
            <xsl:text>      function Internal (Dest           : not null access </xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>;&nl;</xsl:text>
            <xsl:text>                         DeletePointers : in Boolean := True)&nl;</xsl:text>
            <xsl:text>                         return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>TypeSupport_finalize_data_ex");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception&nl;</xsl:text>
            <xsl:text>        (Internal (Dest, DeletePointers),&nl;</xsl:text>
            <xsl:text>         "Unable to finalize data");&nl;</xsl:text>
            <xsl:text>   end Finalize_Data;&nl;&nl;</xsl:text>

            <!-- Finalize -->
            <xsl:text>   --------------&nl;</xsl:text>
            <xsl:text>   -- Finalize --&nl;</xsl:text>
            <xsl:text>   --------------&nl;&nl;</xsl:text>

            <xsl:text>   procedure Finalize is&nl;</xsl:text>
            <xsl:text>      function Internal return Standard.DDS.ReturnCode_T;&nl;</xsl:text>
            <xsl:text>      pragma Import (C, Internal, "</xsl:text>
            <xsl:value-of select="$fullyQualifiedCTypeName"/>
            <xsl:text>TypeSupport_finalize");&nl;</xsl:text>
            <xsl:text>   begin&nl;</xsl:text>
            <xsl:text>      Standard.DDS.Ret_Code_To_Exception (Internal, "Unable to finalize");&nl;</xsl:text>
            <xsl:text>   end Finalize;&nl;&nl;</xsl:text>

            <!-- End package body -->
            <xsl:text>end </xsl:text>
            <xsl:value-of select="$fullyQualifiedAdaTypeName"/>
            <xsl:text>_TypeSupport;&nl;</xsl:text>
        </file>

    </xsl:if> <!-- if topLevel -->
</xsl:template>

</xsl:stylesheet>
