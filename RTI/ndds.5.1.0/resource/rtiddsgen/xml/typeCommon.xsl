<?xml version="1.0"?>
<!-- 
/* $Id: typeCommon.xsl,v 1.11 2013/09/12 14:22:28 fernando Exp $
 
   (c) Copyright, Real-Time Innovations, Inc. 2001.  All rights reserved.
   No duplications, whole or partial, manual or electronic, may be made
   without prior written permission.  Any such copies, or
   revisions thereof, must display this notice unaltered.
   This code contains trade secrets of Real-Time Innovations, Inc.

Modification history:
- - - - - - - - - - -
5.0.1,10may13,acr CODEGEN-574 Check for invalid optional key members
5.0.0,21nov12,fcs Fixed CODEGEN-526: The API DDS_TypeCode_extensibility_kind 
                  may return an incorrect value when called in a TypeCode 
                  generated by rtiddsgen
5.0.0,10jul12,fcs Started CODEGEN-120 fix
10af,13apr11, ai  Added 'bitSet' and 'bitBound' directives
10af, 06apr11, ai  Added 'id' and 'extensibility' directives
10ad,24aug10,fcs Added begin directive to Java
10ad,24aug10,fcs Added begin directive to Ada
10ad,26may10,fcs Fixed metp validation for arrays of strings
10ad,10apr10,fcs Metp validation templates
10ad,21dec09,fcs Added verbosity parameter
10y,30oct08,jlv Added the uppercase version of directive names.
10x,09sep08,fcs Support for const directive
10x,16jul08,rbw Bug #12295: Fixed union discriminator type checking
10x,22may08,rbw Fixed syntax for C++/CLI strings
10s,06mar08,rbw Fixed CPP/CLI string name
10s,13feb08,rbw Refactored unrecognized directive warnings here and added
                C++/CLI-related directives to the lists
10m,05oct06,krb Reverted obtainBaseMemberKind to a previous implementation.
10m,02oct06,krb Fixed bug with typedefs of arrays of typedefed sequences.
10m,28sep06,krb Fixed bug with arrays of typedefed sequences.
10m,05sep06,krb Reverted obtainMemberKind back to a previous implementation.
10m,23jul06,fcs JDK 1.5 support
10m,22jul06,krb Fixed problem when determining member kind while reducing typedefs.
10l,01may06,fcs Merged from BRANCH_NDDSGEN_JAVA_CORBA
10l,19apr06,fcs Fixed error messages format
10h,15dec05,fcs Fixed bug in isLastLessDeepTopLevelType implementation
10e,08dec05,fcs Changed obtainNative type to be language specific        
10e,26jul05,fcs Added isLastLessDeepTopLevelType template
10e,09apr05,fcs Added 'isTopLevelType' template
10e,28mar05,fcs Added getBaseStringLength and getBaseSequenceLength templates
                Added getBaseCardinality
10e,26mar05,fcs Changed templates to get information about the base type
                The new function take into account that the first definition of the type
                can be an alias.                
10e,24mar05,fcs Changed isEnum template for isBaseEnum
10e,18mar05,fcs Added isEnum template
10d,16mar05,fcs Modified for being compatible with the new simplified XML document
10d,27jul04,rw  Moved default rules here from typeCommon.[c|java].xsl
10d,26jul04,rw  Issue errors when //@key appears in wrong place
10c,24may04,rrl Moved in error checking from typeCommon.c.xsl and typeCommon.java.xsl
                and added check for negative length strings and sequences.
40c,18may04,rrl Created
-->

<!--
  Language independent, but nddsgen-specific common templates
  (as opposed to utils.xsl that contains language-independent
   *and* ndds-independent templates)
-->
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"
                xmlns:set="http://exslt.org/sets">

<xsl:param name="coreProduct"/>
<xsl:param name="verbosity"/>
<xsl:param name="validateMetp"/>

<!-- NOTE: tried to have this be the result from a template but the template
           would never return it as a result set/node. -->
<xsl:variable name="allTopLevelStructs"
              select="//struct[count(following-sibling::node())=0 or 
                                      following-sibling::node()[not(name()='directive' 
                                       and position()=1 
                                        and @kind='top-level' 
                                         and text()='false')]]"/>
<!-- NOTE: this variable saves considerable time over iterating through the 
           allTopLevelStructs sequence when dealing with a large IDL set. 
           Also, can't seem to get Xalan to use this predicate in the
           allTopLevelStructs to get everything done in one step. -->
<xsl:variable name="lastTopLevelStructure"
              select="$allTopLevelStructs[last()]"/>
                
<!-- Default rule: Ignore the element and continue applying rules.
     This is especially needed to, by default, ignore text inside 
     <directive> elements. type.h.xsl specifies a rule to process
     directives in a non-default manner.
     
     Note that there appears to be no way to specify a template rule
     that applies to any "mode". This is really unfortunate since
     this forces us to specify an identical rule for each mode, and causes
     incorrect behavior (copy-through of text inside <directive> elements)
     when a new mode is introduced.
-->
<xsl:template match="@*|node()">
    <xsl:apply-templates/>
</xsl:template>

<xsl:template match="@*|node()" mode="code-generation">
    <xsl:apply-templates/>
</xsl:template>

<!-- Template to determinate if a type is a top-level type or not
     The top-level types generate DataReader/DataWriter/Support code
-->

<xsl:template name="isTopLevelType">
    <xsl:param name="typeNode"/>            
    <xsl:choose>
        <xsl:when test="not(name($typeNode)='struct')">
            <xsl:value-of select="'no'"/>                                                              
        </xsl:when>
        <xsl:when test="$typeNode[following-sibling::directive[@kind='top-level' and ./preceding-sibling::struct[@name=$typeNode/@name and position()=1]]/text()='true']">
            <xsl:value-of select="'yes'"/>                                            
        </xsl:when>
        <xsl:when test="$typeNode[following-sibling::directive[@kind='top-level' and ./preceding-sibling::struct[@name=$typeNode/@name and position()=1]]/text()='false']">
            <xsl:value-of select="'no'"/>                                            
        </xsl:when>
        <xsl:otherwise>
            <xsl:value-of select="'yes'"/>
        </xsl:otherwise>
    </xsl:choose>
</xsl:template>        

<!-- Template to determinate if a type is the last top-level type or not -->        
<xsl:template name="isLastLessDeepTopLevelType">
    <xsl:param name="typeNode"/>            
    <xsl:choose>
        <!-- NOTE: I would like to have used fn:deep-equal() here but Xalan doesn't support it. -->
        <xsl:when test="count(set:difference($typeNode, $lastTopLevelStructure))=0">
            <xsl:text>yes</xsl:text>
        </xsl:when>
        <xsl:otherwise>
            <xsl:text>no</xsl:text>
        </xsl:otherwise>
    </xsl:choose>
</xsl:template>        

<!-- Obtain the member's kind (scalar, array, arraySequence, sequence, string, wstring, and bitfield are valid member kinds).
     @param member member node (as defined the simplified IDL/XML schema
     @return the kind of the member
-->     
<xsl:template name="obtainMemberKind">
    <xsl:param name="member"/>
        <xsl:choose>
            <xsl:when test="$member[cardinality] and $member[@kind = 'sequence']">arraySequence</xsl:when>
            <xsl:when test="$member[cardinality]">array</xsl:when>
            <xsl:when test="$member[@kind = 'sequence']">sequence</xsl:when>        
            <xsl:when test="$member[@type='string']">string</xsl:when>
            <xsl:when test="$member[@type='wstring']">wstring</xsl:when>    
            <xsl:when test="$member[@bitField]">bitfield</xsl:when>            
            <xsl:otherwise>scalar</xsl:otherwise>
        </xsl:choose>
</xsl:template>

<!-- Obtain the member's type's kind (user and builtin are valid type kinds).
     @param member member node (as defined the simplified IDL/XML schema
     @return the kind of the type of the member
-->     
<xsl:template name="obtainTypeKind">
    <xsl:param name="member"/>
    <xsl:choose>
        <!-- If we find the matching type in typeInfoMap (defined in
             generation-info.c.xml),  then we have a builtin type; everything
             else is user type -->
        <xsl:when test="$typeInfoMap/type[@idlType=$member/@type]">builtin</xsl:when>
        <xsl:otherwise>user</xsl:otherwise>        
    </xsl:choose>
</xsl:template>


<!-- Next template was introduced with xTypes feature.
       It's meant to retrieve the exensibility kind associated to the data type (extensible [default], mutable, final)
-->
<xsl:template name="getExtensibilityKind">
    <xsl:param name="structName"/>
    <xsl:param name="node"/>
    <xsl:param name="typeKind" select="'struct'"/>

   <xsl:choose>
       <xsl:when test="$typeKind='enum' or name($node) = 'enum'">
           <xsl:choose>
               <xsl:when test="$node/following-sibling::directive
                               [
                               @kind='Extensibility' 
                                   and ./preceding-sibling::enum[@name=$structName and position()=1]
                                   and not(./preceding-sibling::struct
                                       [
                                           position()=1
                                               and ./preceding-sibling::enum[@name=$structName]
                                       ])
                               ]">
                   <xsl:value-of select="$node/following-sibling::directive[@kind='Extensibility'][1]"/>
               </xsl:when>
               <xsl:otherwise>
                   <xsl:value-of select="'EXTENSIBLE_EXTENSIBILITY'"/>
               </xsl:otherwise>
           </xsl:choose>
       </xsl:when>
       <xsl:otherwise>
           <xsl:choose>
               <xsl:when test="$node/following-sibling::directive
                               [
                               @kind='Extensibility' 
                                   and ./preceding-sibling::struct[@name=$structName and position()=1]
                                   and not(./preceding-sibling::enum
                                       [
                                           position()=1
                                               and ./preceding-sibling::struct[@name=$structName]
                                       ])
                               ]">
                   <xsl:value-of select="$node/following-sibling::directive[@kind='Extensibility'][1]"/>
               </xsl:when>
               <xsl:otherwise>
                   <xsl:value-of select="'EXTENSIBLE_EXTENSIBILITY'"/>
               </xsl:otherwise>
           </xsl:choose>
       </xsl:otherwise>
   </xsl:choose>
</xsl:template>    

<!--  -->
<xsl:template name="getBaseType">        
    <xsl:param name="member"/>
    <!-- get the last descendants type attribute as the base type. -->
    <xsl:variable name="allTypeAttrs" 
                  select="$member/descendant-or-self::*/@type"/>
    <xsl:value-of select="$allTypeAttrs[position() = last()]"/>
</xsl:template>

<!-- -->
<xsl:template name="getBaseStringLength">
    <xsl:param name="member"/>        
    <xsl:value-of select="$member/descendant-or-self::member[count($member/descendant-or-self::member)]/@maxLengthString"/>
</xsl:template>

<!-- -->
<xsl:template name="getBaseSequenceLength">
    <xsl:param name="member"/>        
    <xsl:value-of select="$member/descendant-or-self::member/@maxLengthSequence"/>
</xsl:template>

<!-- -->
<xsl:template name="getBaseCardinality">
    <xsl:param name="member"/>        
    <xsl:choose>
        <xsl:when test="$member/cardinality">
            <xsl:copy-of select="$member/cardinality"/>                                            
        </xsl:when>
        <xsl:when test="$member/member/cardinality">
            <xsl:copy-of select="$member/member/cardinality"/>                            
        </xsl:when>        
        <xsl:otherwise>
            <xsl:copy-of select="$member/member/member/cardinality"/>                            
        </xsl:otherwise>
    </xsl:choose>                                            
</xsl:template>


<!-- -->
<xsl:template name="obtainBaseMemberKind">
    <xsl:param name="member"/>
                                    
    <xsl:choose>
        <xsl:when test="$member[cardinality] and $member[@kind = 'sequence']">arraySequence</xsl:when>
        <xsl:when test="$member[cardinality]">array</xsl:when>
        <xsl:when test="$member[@kind = 'sequence']">sequence</xsl:when>        
        <xsl:when test="$member[@type='string']">string</xsl:when>
        <xsl:when test="$member[@type='wstring']">wstring</xsl:when>    
        <xsl:when test="$member[@bitField]">bitfield</xsl:when>    
        <xsl:otherwise>
            <xsl:choose>
                <xsl:when test="$member/member[cardinality] and $member/member[@kind = 'sequence']">arraySequence</xsl:when>
                <xsl:when test="$member/member[cardinality]">array</xsl:when>
                <xsl:when test="$member/member[@kind = 'sequence']">sequence</xsl:when>        
                <xsl:when test="$member/member[@type='string']">string</xsl:when>
                <xsl:when test="$member/member[@type='wstring']">wstring</xsl:when>    
                <xsl:when test="$member/member[@bitField]">bitfield</xsl:when>    
                <xsl:otherwise>scalar</xsl:otherwise>                
            </xsl:choose>
        </xsl:otherwise>        
    </xsl:choose>
    
</xsl:template>

<!-- -->
<xsl:template name="obtainBaseTypeKind">
    <xsl:param name="member"/>

    <xsl:variable name="baseType" select="$member/descendant-or-self::*/@type"/>

    <xsl:choose>
        <xsl:when test="$typeInfoMap/type[@idlType=$baseType]">builtin</xsl:when>
        <xsl:otherwise>user</xsl:otherwise>                        
    </xsl:choose>        

</xsl:template>
        

<!-- Obtain the bitKind, extra information for bit-field code generation. 
     (ignore, normal, lastBitField are valid kinds)  
     @param member member node (as defined the simplified IDL/XML schema
     @return next member kind
-->     
<xsl:template name="obtainBitKind">
    <xsl:param name="member"/>
    <xsl:if test="$member[@bitField]">
    <xsl:choose>
        <!-- ignore unnamed bit-fields in code generation, test whether name
             is blank rather than testing if the bit-field size is 0 as 
             unnamed bit-fields could be larger than 0 length -->
        <xsl:when test="$member[@name='']">ignore</xsl:when>
        <!-- find if there is another bit-field member immediately following 
             note that [@name!=''][1] finds the first following member that has a 
             name, this is to ignore unnamed bit-fields -->
        <xsl:when test="$member/following-sibling::member[@name!=''][1]/@bitField">normal</xsl:when>    
        <xsl:otherwise>lastBitField</xsl:otherwise>
    </xsl:choose>
    </xsl:if>
</xsl:template>

<!-- -->
<xsl:template name="obtainBaseBitKind">    
    <xsl:param name="member"/>
    
    <xsl:if test="$member[@bitField]">
        <xsl:call-template name="obtainBitKind">                
            <xsl:with-param name="member" select="$member"/>
        </xsl:call-template>
    </xsl:if>        
    
    <xsl:if test="not($member[@bitField])">
        <xsl:if test="$member/member">
            <xsl:call-template name="obtainBitKind">                
                <xsl:with-param name="member" select="$member/member"/>
            </xsl:call-template>
        </xsl:if>        
    </xsl:if>                       
</xsl:template>

<!-- -->
<xsl:template name="obtainBaseBitField">    
    <xsl:param name="member"/>
    
    <xsl:if test="$member[@bitField]">
        <xsl:value-of select="$member/@bitField"/>
    </xsl:if>        
    
    <xsl:if test="not($member[@bitField])">
        <xsl:if test="$member/member">
            <xsl:value-of select="$member/member/@bitField"/>
        </xsl:if>        
    </xsl:if>                       
</xsl:template>

<!-- -->
<xsl:template name="isBaseEnum">
    <xsl:param name="member"/>
    <xsl:variable name="enumAttrs" select="$member/descendant-or-self::*/@enum"/>

    <xsl:choose>
        <xsl:when test="$enumAttrs[last()]='yes'">yes</xsl:when>
        <xsl:otherwise>no</xsl:otherwise>
    </xsl:choose>                                
</xsl:template>

<xsl:template name="isMemberKey">
    <xsl:param name="member"/>
    <xsl:choose>
        <xsl:when test="$member[following-sibling::node()[position() = 1 and name() = 'directive' and @kind = 'key']]">yes</xsl:when>
        <xsl:otherwise>no</xsl:otherwise>
    </xsl:choose>                                
</xsl:template>
        
<!-- Obtain native type given the IDL type.
	 @param idlType type name in IDL
	 @return native type name
-->
<xsl:template name="obtainNativeType">
    <xsl:param name="idlType"/>        	
    <xsl:variable name="typeNode" select="$typeInfoMap/type[@idlType=$idlType]"/>
    <xsl:choose>
        <xsl:when test="$typeNode"><xsl:value-of select="$typeNode/@nativeType"/></xsl:when>
        <xsl:when test="($idlType='string' or $idlType='wstring') and $language='JAVA'">
            <xsl:text>String</xsl:text>
        </xsl:when>
        <xsl:when test="($idlType='string' or $idlType='wstring') and $language='C++/CLI'">
            <xsl:text>System::String^</xsl:text>
        </xsl:when>
        <xsl:when test="($idlType='string') and $language='Ada'">
            <xsl:text>Standard.DDS.String</xsl:text>
        </xsl:when>
        <xsl:when test="($idlType='wstring') and $language='Ada'">
            <xsl:text>Standard.DDS.Wide_String</xsl:text>
        </xsl:when>
        <xsl:when test="$idlType='string'">
            <xsl:text>char *</xsl:text>
        </xsl:when>                    
        <xsl:when test="$idlType='wstring'">                
            <xsl:value-of select="$typeInfoMap/type[@idlType='wchar']"/>
            <xsl:text> *</xsl:text>                
        </xsl:when>                    
        <xsl:otherwise><xsl:value-of select="$idlType"/></xsl:otherwise>
    </xsl:choose>
</xsl:template>

<!-- XType template -->
<xsl:template name="needExtendedParameterId">
    <xsl:param name="member"/>
    <xsl:param name="baseMemberKind"/>
    <xsl:param name="baseTypeKind"/>

    <xsl:variable name="baseEnum">    
        <xsl:call-template name="isBaseEnum">
            <xsl:with-param name="member" select="$member"/>
        </xsl:call-template>        
    </xsl:variable>

    <xsl:choose>
        <xsl:when test="$member/@memberId > 16128">yes</xsl:when>
        <xsl:when test="$baseEnum = 'yes' and $baseMemberKind = 'scalar'">no</xsl:when>
        <xsl:when test="$baseTypeKind = 'builtin' and $baseMemberKind = 'scalar'">no</xsl:when>
        <xsl:otherwise>maybe</xsl:otherwise>
    </xsl:choose>
</xsl:template>


<!-- ===================================================================== -->
<!-- Member validation                                                     -->
<!-- ===================================================================== -->

<!-- -->
<xsl:template name="validateMetpType">
    <xsl:param name="module"/>
    <xsl:param name="typeName"/>

    <xsl:choose>
        <xsl:when test="$module/struct[@name = $typeName]">
            <xsl:for-each select="$module/struct[@name = $typeName]/member">
                <xsl:call-template name="validateMetpMemberRec">
                    <xsl:with-param name="member" select="."/>
                </xsl:call-template>
            </xsl:for-each>
        </xsl:when>
        <xsl:otherwise>
            <xsl:variable name="moduleName">
                <xsl:value-of select="substring-before($typeName,'::')"/>
            </xsl:variable>

            <xsl:if test="$moduleName != ''">
                <!-- Modules can be reopened -->
                <xsl:for-each select="$module/module[@name = $moduleName]">
                    <xsl:variable name="newTypeName">
                        <xsl:value-of select="substring-after($typeName,'::')"/>
                    </xsl:variable>

                    <xsl:call-template name="validateMetpType">
                        <xsl:with-param name="module" select="."/>
                        <xsl:with-param name="typeName" select="$newTypeName"/>
                    </xsl:call-template>
                </xsl:for-each>
            </xsl:if>
        </xsl:otherwise>
    </xsl:choose>
</xsl:template>

<!-- -->
<xsl:template name="validateMetpMemberRec">
    <xsl:param name="member"/>

    <xsl:variable name="baseMemberKind">
        <xsl:call-template name="obtainBaseMemberKind">
            <xsl:with-param name="member" select="$member"/>
        </xsl:call-template>
    </xsl:variable>
    
    <xsl:if test="$baseMemberKind = 'arraySequence' or
                  $baseMemberKind = 'sequence'">
        <xsl:message terminate="yes">
            <xsl:text> Error: error generating code for member '</xsl:text>
            <xsl:value-of select="concat(../@name,'.',@name)"/>
            <xsl:text>'. Sequences are not supported with the -metp option.</xsl:text>
        </xsl:message>
    </xsl:if>

    <xsl:if test="$baseMemberKind = 'string' or
                  $baseMemberKind = 'wstring'">
        <xsl:message terminate="yes">
            <xsl:text> Error: error generating code for member '</xsl:text>
            <xsl:value-of select="concat(../@name,'.',@name)"/>
            <xsl:text>'. Strings are not supported with the -metp option.</xsl:text>
        </xsl:message>
    </xsl:if>

    <xsl:variable name="basePointer">
        <xsl:choose>
            <xsl:when test="$member/member/@pointer = 'yes'">
                <xsl:value-of select="'yes'"/>                            
            </xsl:when>
            <xsl:when test="$member/@pointer = 'yes'">
                <xsl:value-of select="'yes'"/>                            
            </xsl:when>            
            <xsl:otherwise>
                <xsl:value-of select="'no'"/>                            
            </xsl:otherwise>
        </xsl:choose>                                
    </xsl:variable>

    <xsl:if test="$basePointer = 'yes'">
        <xsl:message terminate="yes">
            <xsl:text> Error: error generating code for member '</xsl:text>
            <xsl:value-of select="concat(../@name,'.',@name)"/>
            <xsl:text>'. Pointers are not supported with the -metp option.</xsl:text>
        </xsl:message>
    </xsl:if>

    <xsl:variable name="baseTypeKind">
        <xsl:call-template name="obtainBaseTypeKind">
            <xsl:with-param name="member" select="$member"/>
        </xsl:call-template>
    </xsl:variable>

    <xsl:if test="$baseTypeKind = 'user'">
        <xsl:variable name="baseType">
            <xsl:call-template name="getBaseType">
                <xsl:with-param name="member" select="$member"/>        
            </xsl:call-template>        
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$baseType = 'string' or $baseType = 'wstring'">
                <xsl:message terminate="yes">
                    <xsl:text> Error: error generating code for member '</xsl:text>
                    <xsl:value-of select="concat(../@name,'.',@name)"/>
                    <xsl:text>'. Strings are not supported with the -metp option.</xsl:text>
                </xsl:message>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="validateMetpType">
                    <xsl:with-param name="module" select="/specification"/>
                    <xsl:with-param name="typeName" select="$baseType"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:if>    
</xsl:template>

<!-- -->
<xsl:template name="validateMetpMember">
    <xsl:param name="member"/>

    <xsl:if test="$validateMetp = 'yes'">
        <xsl:variable name="isKeyed">
            <xsl:choose>
                <xsl:when test="following-sibling::node()[position() = 1 and name() = 'directive' and @kind = 'key']">yes</xsl:when>
                <xsl:otherwise>no</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:if test="$isKeyed = 'yes'">
            <xsl:message terminate="yes">
                <xsl:text> Error: error generating code for member '</xsl:text>
                <xsl:value-of select="concat(../@name,'.',@name)"/>
                <xsl:text>'. Keys are not supported with the -metp option.</xsl:text>
            </xsl:message>
        </xsl:if>

        <xsl:variable name="topLevel">
            <xsl:call-template name="isTopLevelType">
                <xsl:with-param name="typeNode" select=".."/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:if test="$topLevel = 'yes'">
            <xsl:call-template name="validateMetpMemberRec">
                <xsl:with-param name="member" select="$member"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:if>
</xsl:template>

<!-- ===================================================================== -->
<!-- Error and warning templates                                           -->
<!-- ===================================================================== -->
        
<xsl:template match="@*|node()" mode="error-checking">
    <xsl:apply-templates/>
</xsl:template>


<!-- Template to generate warning for a misplaced @key directive.

     If the sibling node immediately preceding the directive is not a struct
     member, it's an error.
-->
<xsl:template match="directive[@kind = 'key' and name(..) != 'struct']">
    <xsl:message terminate="yes">
        <xsl:text> Error: The //@key directive may only appear within a structure.</xsl:text>
    </xsl:message>
</xsl:template>

<xsl:template match="struct/directive[@kind = 'key']" mode="error-checking">
    <xsl:variable name="previousNode"
                  select="preceding-sibling::node()[position() = 1]"/>
    <xsl:choose>
        <xsl:when test="not($previousNode) or $previousNode[not(name() = 'member')]">
            <xsl:message terminate="yes">
                <xsl:text> Error: The //@key directive may appear only immediately following a struct member.</xsl:text>
            </xsl:message>
        </xsl:when>
    </xsl:choose>
</xsl:template>

        
<!-- Disallow unbounded strings and unbounded sequences.
     We could extend this logic for other kinds of errors and warning. In
     case of warnings, you will need to set the "terminate" attribute to "no".
     
     Note that we check for not(@maxLength) (unset attribute) and @maxLength=''
     (empty attribute value) to ensure that we cover the case where maxLength
     attribute is missing or set to empty value to guard against possible
     inconsistency in how the simplified schema is interpreted and implemented.
-->
<xsl:template match="member" mode="error-checking">
    <xsl:variable name="type">
        <xsl:call-template name="getBaseType">
            <xsl:with-param name="member" select="."/>        
        </xsl:call-template>        
    </xsl:variable>
    
    <xsl:variable name="memberKind">
        <xsl:call-template name="obtainBaseMemberKind">
            <xsl:with-param name="member" select="."/>        
        </xsl:call-template>        
    </xsl:variable>
        
    <xsl:variable name="bitField">
        <xsl:call-template name="obtainBaseBitField">
            <xsl:with-param name="member" select="."/>        
        </xsl:call-template>        
    </xsl:variable>
    
    <xsl:variable name="isKey">
        <xsl:call-template name="isMemberKey">
            <xsl:with-param name="member" select="."/>        
        </xsl:call-template>        
    </xsl:variable>
    
    <!-- Keys can't be optional -->
    <xsl:if test="$isKey='yes' and @optional='true'">
        <xsl:message  terminate="yes">
            <xsl:text> Error: Member '</xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>': keys can't be optional</xsl:text>
        </xsl:message>
    </xsl:if>
    
    <xsl:if test="@pointer='yes' and @optional='true'">
        <xsl:message  terminate="yes">
            <xsl:text> Error: Member '</xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>': a pointer member can't be optional</xsl:text>
        </xsl:message>
    </xsl:if>    
    
    <!-- Optional annotation makes sense only in structs and valuetypes -->
    <xsl:if test="@optional='true' and ../@kind != 'struct' and ../@kind != 'valuetype'">
        <xsl:message  terminate="yes">
            <xsl:text> Error: Member '</xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>': Optional annotation is only allowed in structs or valuetypes</xsl:text>
        </xsl:message>
    </xsl:if>        
                                         
    <!-- check for bit fields of unsupported types -->
    <xsl:if test="($bitField!='') and ($memberKind='sequence' or $memberKind='arraySequence')">
        <xsl:message  terminate="yes">
            <xsl:text> Error: Member '</xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>': Bit fields are not allowed with a sequence or an array of sequences.</xsl:text>
        </xsl:message>
    </xsl:if>  
    <xsl:if test="($bitField!='') and not($type='octet' or $type='char' or $type='wchar' or
    								  $type='short' or $type='unsignedshort' or
    								  $type='long' or $type='unsignedlong')">
        <xsl:message  terminate="yes">
            <xsl:text> Error: Member '</xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>': Bit fields are not allowed with type </xsl:text><xsl:value-of select="$type"/>
            <xsl:text>.</xsl:text>
        </xsl:message>
    </xsl:if>
    
    <!-- check for a too large bit field length (only checks integers, not 
         const expressions) -->
    <xsl:if test="($bitField!='') and not(string(number($bitField))='NaN')">
        <xsl:if test="($bitField&gt;8) and ($type='octet' or $type='char')">
            <xsl:message  terminate="yes">
                <xsl:text> Error: Member '</xsl:text>
                <xsl:value-of select="@name"/>
                <xsl:text>': Bit fields of type </xsl:text><xsl:value-of select="$type"/>
                <xsl:text> must be 8 bits or less.</xsl:text>
            </xsl:message>
    	</xsl:if>
    	<xsl:if test="($bitField&gt;16) and ($type='short' or $type='unsignedshort'or $type='wchar')">
            <xsl:message  terminate="yes">
                <xsl:text> Error: Member '</xsl:text>
                <xsl:value-of select="@name"/>
                <xsl:text>': Bit fields of type </xsl:text><xsl:value-of select="$type"/>
                <xsl:text> must be 16 bits or less.</xsl:text>
            </xsl:message>
    	</xsl:if>
    	<xsl:if test="($bitField&gt;32) and ($type='long' or $type='unsignedlong')">
            <xsl:message  terminate="yes">
                <xsl:text> Error: Member '</xsl:text>
                <xsl:value-of select="@name"/>
                <xsl:text>': Bit fields of type </xsl:text><xsl:value-of select="$type"/>
                <xsl:text> must be 32 bits or less.</xsl:text>
            </xsl:message>
    	</xsl:if>

    	<!-- check for a named 0 length bit field -->
    	<xsl:if test="($bitField=0) and (@name!='')">
       	    <xsl:message  terminate="yes">
                <xsl:text> Error: Member '</xsl:text>
                <xsl:value-of select="@name"/>
        	<xsl:text>': 0 length bit field not allowed unless unnamed.</xsl:text>
            </xsl:message>
    	</xsl:if>
    	<!-- check for a negative length bit field -->
    	<xsl:if test="($bitField&lt;0)">
            <xsl:message  terminate="yes">
                <xsl:text> Error: Member '</xsl:text>
                <xsl:value-of select="@name"/>
                <xsl:text>': Negative size bit field not allowed.</xsl:text>
            </xsl:message>
    	</xsl:if>
     </xsl:if>
</xsl:template>

<!-- Disallow unions discriminators that don't allow to the following class:
     integer_type
     boolean_type
     enum_type
     scoped_name
-->
    
<xsl:template match="discriminator" mode="error-checking">            

    <xsl:variable name="type">
        <xsl:call-template name="getBaseType">
            <xsl:with-param name="member" select="."/>        
        </xsl:call-template>        
    </xsl:variable>
    
    <xsl:variable name="memberKind">
        <xsl:call-template name="obtainBaseMemberKind">
            <xsl:with-param name="member" select="."/>        
        </xsl:call-template>        
    </xsl:variable>
    
    <xsl:variable name="typeKind">
        <xsl:call-template name="obtainBaseTypeKind">
            <xsl:with-param name="member" select="."/>        
        </xsl:call-template>        
    </xsl:variable>
        
    <xsl:choose>               
        <!-- this check discards arrays of arrays of wstring -->
        <xsl:when test="$memberKind != 'scalar'">                
            <xsl:message  terminate="yes">
                <xsl:text> Error: The discriminator type for the union </xsl:text>
                <xsl:value-of select="../@name"/>
                <xsl:text> has to be: integer, char, boolean or enumerated</xsl:text>
            </xsl:message>                                
        </xsl:when>                
        <xsl:when test="$typeKind='builtin' and ($type != 'char' and $type!='boolean'
                        and $type!='short' and $type!='long' and $type!='longlong' and
                        $type!='unsignedshort' and $type!='unsignedlong' and 
                        $type!='unsignedlonglong')">
            <xsl:message  terminate="yes">
                <xsl:text> Error: The discriminator type for the union </xsl:text>
                <xsl:value-of select="../@name"/>
                <xsl:text> has to be: integer, char, boolean or enumerated</xsl:text>
            </xsl:message>                                                                        
        </xsl:when>
        <xsl:otherwise>
        </xsl:otherwise>
    </xsl:choose>    
    
</xsl:template>        

<xsl:template match="directive[@kind != 'copy' and
                               @kind != 'copy-c' and
                               @kind != 'copy-java' and
                               @kind != 'copy-java-begin' and
                               @kind != 'copy-cppcli' and
                               @kind != 'copy-ada' and
                               @kind != 'copy-ada-begin' and
                               @kind != 'copy-declaration' and
                               @kind != 'copy-ada-declaration' and
                               @kind != 'copy-ada-declaration-begin' and
                               @kind != 'copy-c-declaration' and
                               @kind != 'copy-java-declaration' and
                               @kind != 'copy-java-declaration-begin' and
                               @kind != 'copy-cppcli-declaration' and
                               @kind != 'key' and
                               @kind != 'Key' and
                               @kind != 'resolve-name' and
                               @kind != 'ID' and
                               @kind != 'top-level' and
                               @kind != 'const' and
                               @kind != 'copyC' and
                               @kind != 'copyJava' and
                               @kind != 'copyJavaBegin' and
                               @kind != 'copyJavaDeclaration' and
                               @kind != 'copyJavaDeclarationBegin' and
                               @kind != 'copyCppcli' and
                               @kind != 'copyDeclaration' and
                               @kind != 'copyCDeclaration' and
                               @kind != 'copyCppcliDeclaration' and
                               @kind != 'resolveName' and
                               @kind != 'topLevel' and 
                               @kind != 'Extensibility' and 
                               @kind != 'BitSet' and 
                               @kind != 'BitBound'
                               ]"
                     mode="code-generation">
<xsl:if test="$verbosity >= 2">
    <xsl:message>
        <xsl:text> Warning: Directive '</xsl:text><xsl:value-of select="@kind"/>
        <xsl:text>' not recognized. The directive will be ignored.</xsl:text>
    </xsl:message>
</xsl:if>
</xsl:template>

</xsl:stylesheet>
