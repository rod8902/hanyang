<?xml version="1.0"?>
<!--
   $Id: type.adb.xsl,v 1.5 2011/12/04 01:50:15 fernando Exp $

   (c) Copyright 2007, Real-Time Innovations, Inc.  All rights reserved.
   No duplications, whole or partial, manual or electronic, may be made
   without prior written permission.  Any such copies, or
   revisions thereof, must display this notice unaltered.
   This code contains trade secrets of Real-Time Innovations, Inc.

Modification history
 - - - - - - - - - -
10o,24aug10,fcs begin directive support
10o,19jul10,eys Updated to work with 4.5c
10o,17jun08,fcs Group types into modules
10o,29nov07,fcs 11/29/07 Merge changes
10o,12nov07,fcs Mark changes 11/12/07
10o,09nov07,fcs Support for unions
10o,09nov07,fcs Mark changes 11/02/07
10o,25oct07,fcs Support for typedefs
10o,09jul07,fcs Second review changes
10o,07jul07,fcs First review changes
10o,06jul07,rbw Fixed typo in param declaration
10o,06jul07,rbw Improved stylesheet formatting;
                many fixes to struct generation
10o,05jul07,rbw Started filling in Ada implementation
                (still incomplete and buggy)
10o,05jul07,fcs Commented type code references
10o,03jul07,fcs Fixed obtainSourceFileName calls
10o,03jul07,rbw Generate code into multiple files
10o,03jul07,rbw Created based on C version
-->

<!DOCTYPE xsl:stylesheet [
<!ENTITY nl "&#xa;">                <!-- new line -->
<!ENTITY indent "    ">             <!-- indentation -->
<!ENTITY namespaceSeperator ".">    <!-- namespace separator -->
]>

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"
        xmlns:xalan = "http://xml.apache.org/xalan">

<xsl:include href="typeCommon.ada.xsl"/>

<xsl:output method="xml"/>

<xsl:variable name="sourcePreamble" select="$generationInfo/sourcePreamble[@kind = 'type-source']"/>

<xsl:template match="/">

    <xsl:variable name="sourceFile">
        <xsl:call-template name="lower-case">
            <xsl:with-param name="text" select="concat($idlFileBaseName,'_idl_file.adb')"/>
        </xsl:call-template>
    </xsl:variable>

    <xsl:if test="./specification/node()[name(.)='struct']|
                  ./specification/node()[name(.)='typedef']|
                  ./specification/node()[name(.)='enum']">
        <file name="{$sourceFile}">
            <xsl:variable name="containerNamespace">
                <xsl:value-of select="$idlFileBaseName"/>
            </xsl:variable>
            <xsl:variable name="fullContainerNamespace">
                <xsl:value-of select="concat($idlFileBaseName,'_IDL_File')"/>
            </xsl:variable>
    
            <xsl:call-template name="printAutoGeneratedWarning"/>
    
            <!-- Generate type declaration -->
            <xsl:text>with RTI;&nl;</xsl:text>
    
            <xsl:apply-templates select="./specification/directive[@kind = 'copy-ada-begin']"/>
    
            <!-- Begin package body -->
            <xsl:value-of select="concat('package body ',$fullContainerNamespace,' is')"/>
            <xsl:text>&nl;&nl;</xsl:text>
    
            <xsl:text>   use type Standard.RTI.Bool;&nl;</xsl:text>
    
            <xsl:apply-templates select="./specification/node()[
                                            name(.)!='module' and 
                                            not(name(.)='directive' and 
                                                ./@kind = 'copy-ada-begin')]">
                <xsl:with-param name="containerNamespace" select="$containerNamespace"/>
                <xsl:with-param name="hasModule" select="0"/>
            </xsl:apply-templates>
    
            <!-- End package body -->
            <xsl:text>end </xsl:text>
            <xsl:value-of select="$fullContainerNamespace"/>
            <xsl:text>;&nl;</xsl:text>
        </file>
    </xsl:if>

    <xsl:for-each select="//module">
        <xsl:variable name="containerNamespace">
            <xsl:call-template name="getModulePath">
                <xsl:with-param name="moduleNode" select="."/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="sourceFile">
            <xsl:call-template name="obtainSourceFileName">
                <xsl:with-param name="containerNamespace"
                                select="$containerNamespace"/>
                <xsl:with-param name="typeName" select="''"/>
                <xsl:with-param name="fileExt" select="'adb'"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:if test="./node()[name(.)='struct']|
                      ./node()[name(.)='typedef']|
                      ./node()[name(.)='enum']">
            <file name="{$sourceFile}">
                <xsl:call-template name="printAutoGeneratedWarning"/>
    
                <!-- Generate type declaration -->
                <xsl:text>with RTI;&nl;</xsl:text>
    
                <xsl:apply-templates select="/specification/directive[@kind = 'copy-ada-begin']"/>
    
                <!-- Begin package body -->
                <xsl:value-of select="concat('package body ',$containerNamespace,' is')"/>
                <xsl:text>&nl;&nl;</xsl:text>
    
                <xsl:text>   use type Standard.RTI.Bool;&nl;</xsl:text>
    
                <xsl:apply-templates select="./node()[name(.)!='module']">
                    <xsl:with-param name="containerNamespace" select="$containerNamespace"/>
                    <xsl:with-param name="hasModule" select="1"/>
                </xsl:apply-templates>
    
                <!-- End package body -->
                <xsl:text>end </xsl:text>
                <xsl:value-of select="$containerNamespace"/>
                <xsl:text>;&nl;</xsl:text>
            </file>
        </xsl:if>
    </xsl:for-each>
</xsl:template>

<xsl:template match="enum">
    <xsl:param name="containerNamespace"/>
    <xsl:param name="hasModule"/>

    <xsl:variable name="fullyQualifiedAdaStructName">
        <xsl:choose>
            <xsl:when test="$hasModule=1">
                <xsl:value-of select="concat($containerNamespace,'.',@name)"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="@name"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:variable>

    <xsl:variable name="fullyQualifiedCStructName" select="translate($fullyQualifiedAdaStructName,'.','_')"/>

    <xsl:apply-templates mode="error-checking"/>

    <!-- Initialize method -->
    <xsl:text>   procedure Initialize&nl;</xsl:text>
    <xsl:text>     (This : in out </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>) is&nl;</xsl:text>
    <xsl:text>      function Internal&nl;</xsl:text>
    <xsl:text>        (This : not null access </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>)&nl;</xsl:text>
    <xsl:text>         return Standard.RTI.Bool;&nl;</xsl:text>
    <xsl:text>      pragma Import (C, Internal, "</xsl:text>
    <xsl:value-of select="$fullyQualifiedCStructName"/>
    <xsl:text>_initialize_ex");&nl;</xsl:text>
    <xsl:text>   begin&nl;</xsl:text>
    <xsl:text>      if not Internal (This'Unrestricted_Access) then&nl;</xsl:text>
    <xsl:text>         raise Standard.DDS.ERROR with "unable to initialize";&nl;</xsl:text>
    <xsl:text>      end if;&nl;</xsl:text>
    <xsl:text>   end Initialize;&nl;&nl;</xsl:text>

    <!-- Finalize method -->
    <xsl:text>   procedure Finalize&nl;</xsl:text>
    <xsl:text>     (This            : in out </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>) is&nl;</xsl:text>
    <xsl:text>      procedure Internal&nl;</xsl:text>
    <xsl:text>        (This : access </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>;&nl;</xsl:text>
    <xsl:text>         deletePointers : Standard.RTI.Bool);&nl;</xsl:text>
    <xsl:text>      pragma Import (C, Internal, "</xsl:text>
    <xsl:value-of select="$fullyQualifiedCStructName"/>
    <xsl:text>_finalize_ex");&nl;</xsl:text>
    <xsl:text>   begin&nl;</xsl:text>
    <xsl:text>      Internal (This'Unrestricted_Access, Standard.RTI.RTI_BOOL_TRUE);&nl;</xsl:text>
    <xsl:text>   end Finalize;&nl;&nl;</xsl:text>

    <!-- Copy method -->
    <xsl:text>   procedure Copy&nl;</xsl:text>
    <xsl:text>     (Dst : in out </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>;&nl;</xsl:text>
    <xsl:text>      Src : in </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>) is&nl;</xsl:text>
    <xsl:text>      function Internal&nl;</xsl:text>
    <xsl:text>        (Dst : not null access </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>;&nl;</xsl:text>
    <xsl:text>         Src : not null access </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>)&nl;</xsl:text>
    <xsl:text>         return Standard.RTI.Bool;&nl;</xsl:text>
    <xsl:text>      pragma Import (C, Internal, "</xsl:text>
    <xsl:value-of select="$fullyQualifiedCStructName"/>
    <xsl:text>_copy");&nl;</xsl:text>
    <xsl:text>   begin&nl;</xsl:text>
    <xsl:text>      if not Internal (Dst'Unrestricted_Access, Src'Unrestricted_Access) then&nl;</xsl:text>
    <xsl:text>         raise Standard.DDS.ERROR with "unable to copy";&nl;</xsl:text>
    <xsl:text>      end if;&nl;</xsl:text>
    <xsl:text>   end Copy;&nl;&nl;</xsl:text>
</xsl:template>

<xsl:template match="struct">
    <xsl:param name="containerNamespace"/>
    <xsl:param name="hasModule"/>

    <xsl:variable name="fullyQualifiedAdaStructName">
        <xsl:choose>
            <xsl:when test="$hasModule=1">
                <xsl:value-of select="concat($containerNamespace,'.',@name)"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="@name"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:variable>

    <xsl:variable name="fullyQualifiedCStructName" select="translate($fullyQualifiedAdaStructName,'.','_')"/>

    <xsl:apply-templates mode="error-checking"/>

    <!-- Initialize method -->
    <xsl:text>   procedure Initialize&nl;</xsl:text>
    <xsl:text>     (This              : in out </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>) is&nl;</xsl:text>
    <xsl:text>      function Internal&nl;</xsl:text>
    <xsl:text>        (This : not null access </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>)&nl;</xsl:text>
    <xsl:text>         return Standard.RTI.Bool;&nl;</xsl:text>
    <xsl:text>      pragma Import (C, Internal, "</xsl:text>
    <xsl:value-of select="$fullyQualifiedCStructName"/>
    <xsl:text>_initialize_ex");&nl;</xsl:text>
    <xsl:text>   begin&nl;</xsl:text>
    <xsl:text>      if not Internal (This'Unrestricted_Access) then&nl;</xsl:text>
    <xsl:text>         raise Standard.DDS.ERROR with "unable to initialize";&nl;</xsl:text>
    <xsl:text>      end if;&nl;</xsl:text>
    <xsl:text>   end Initialize;&nl;&nl;</xsl:text>

    <!-- Finalize method -->
    <xsl:text>   procedure Finalize&nl;</xsl:text>
    <xsl:text>     (This            : in out </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>) is&nl;</xsl:text>
    <xsl:text>      procedure Internal&nl;</xsl:text>
    <xsl:text>        (This : access </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>;&nl;</xsl:text>
    <xsl:text>         deletePointers : Standard.RTI.Bool);&nl;</xsl:text>
    <xsl:text>      pragma Import (C, Internal, "</xsl:text>
    <xsl:value-of select="$fullyQualifiedCStructName"/>
    <xsl:text>_finalize_ex");&nl;</xsl:text>
    <xsl:text>   begin&nl;</xsl:text>
    <xsl:text>      Internal (This'Unrestricted_Access, Standard.RTI.RTI_BOOL_TRUE);&nl;</xsl:text>
    <xsl:text>   end Finalize;&nl;&nl;</xsl:text>

    <!-- Copy method -->
    <xsl:text>   procedure Copy&nl;</xsl:text>
    <xsl:text>     (Dst : in out </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>;&nl;</xsl:text>
    <xsl:text>      Src : in </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>) is&nl;</xsl:text>
    <xsl:text>      function Internal&nl;</xsl:text>
    <xsl:text>        (Dst : not null access </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>;&nl;</xsl:text>
    <xsl:text>         Src : not null access </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>)&nl;</xsl:text>
    <xsl:text>         return Standard.RTI.Bool;&nl;</xsl:text>
    <xsl:text>      pragma Import (C, Internal, "</xsl:text>
    <xsl:value-of select="$fullyQualifiedCStructName"/>
    <xsl:text>_copy");&nl;</xsl:text>
    <xsl:text>   begin&nl;</xsl:text>
    <xsl:text>      if not Internal (Dst'Unrestricted_Access, Src'Unrestricted_Access) then&nl;</xsl:text>
    <xsl:text>         raise Standard.DDS.ERROR with "unable to copy";&nl;</xsl:text>
    <xsl:text>      end if;&nl;</xsl:text>
    <xsl:text>   end Copy;&nl;&nl;</xsl:text>
</xsl:template>

<xsl:template match="typedef">
    <xsl:param name="containerNamespace"/>
    <xsl:param name="hasModule"/>

    <xsl:variable name="fullyQualifiedAdaStructName">
        <xsl:choose>
            <xsl:when test="$hasModule=1">
                <xsl:value-of select="concat($containerNamespace,'.',@name)"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="@name"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:variable>

    <xsl:variable name="fullyQualifiedCStructName" select="translate($fullyQualifiedAdaStructName,'.','_')"/>

    <xsl:apply-templates mode="error-checking"/>

    <!-- Initialize method -->
    <xsl:text>   procedure Initialize&nl;</xsl:text>
    <xsl:text>     (This              : in out </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>) is&nl;</xsl:text>
    <xsl:text>      function Internal&nl;</xsl:text>
    <xsl:text>        (This : not null access </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>)&nl;</xsl:text>
    <xsl:text>         return Standard.RTI.Bool;&nl;</xsl:text>
    <xsl:text>      pragma Import (C, Internal, "</xsl:text>
    <xsl:value-of select="$fullyQualifiedCStructName"/>
    <xsl:text>_initialize_ex");&nl;</xsl:text>
    <xsl:text>   begin&nl;</xsl:text>
    <xsl:text>      if not Internal (This'Unrestricted_Access) then&nl;</xsl:text>
    <xsl:text>         raise Standard.DDS.ERROR with "unable to initialize";&nl;</xsl:text>
    <xsl:text>      end if;&nl;</xsl:text>
    <xsl:text>   end Initialize;&nl;&nl;</xsl:text>

    <!-- Finalize method -->
    <xsl:text>   procedure Finalize&nl;</xsl:text>
    <xsl:text>     (This            : in out </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>) is&nl;</xsl:text>
    <xsl:text>      procedure Internal&nl;</xsl:text>
    <xsl:text>        (This : access </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>;&nl;</xsl:text>
    <xsl:text>         deletePointers : Standard.RTI.Bool);&nl;</xsl:text>
    <xsl:text>      pragma Import (C, Internal, "</xsl:text>
    <xsl:value-of select="$fullyQualifiedCStructName"/>
    <xsl:text>_finalize_ex");&nl;</xsl:text>
    <xsl:text>   begin&nl;</xsl:text>
    <xsl:text>      Internal (This'Unrestricted_Access, Standard.RTI.RTI_BOOL_TRUE);&nl;</xsl:text>
    <xsl:text>   end Finalize;&nl;&nl;</xsl:text>

    <!-- Copy method -->
    <xsl:text>   procedure Copy&nl;</xsl:text>
    <xsl:text>     (Dst : in out </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>;&nl;</xsl:text>
    <xsl:text>      Src : in </xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>) is&nl;</xsl:text>
    <xsl:text>      function Internal&nl;</xsl:text>
    <xsl:text>        (Dst : not null access </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>;&nl;</xsl:text>
    <xsl:text>         Src : not null access </xsl:text>
    <xsl:value-of select="@name"/><xsl:text>)&nl;</xsl:text>
    <xsl:text>         return Standard.RTI.Bool;&nl;</xsl:text>
    <xsl:text>      pragma Import (C, Internal, "</xsl:text>
    <xsl:value-of select="$fullyQualifiedCStructName"/>
    <xsl:text>_copy");&nl;</xsl:text>
    <xsl:text>   begin&nl;</xsl:text>
    <xsl:text>      if not Internal (Dst'Unrestricted_Access, Src'Unrestricted_Access) then&nl;</xsl:text>
    <xsl:text>         raise Standard.DDS.ERROR with "unable to copy";&nl;</xsl:text>
    <xsl:text>      end if;&nl;</xsl:text>
    <xsl:text>   end Copy;&nl;&nl;</xsl:text>
</xsl:template>

<!--
-->
<xsl:template name="getModulePath">
    <xsl:param name="moduleNode"/>  <!-- may be a module node or the specification node (root) --> 

    <xsl:for-each select="$moduleNode/ancestor::module">
        <xsl:value-of select="concat(@name,'.')"/>
    </xsl:for-each>
    <xsl:value-of select="@name"/>

</xsl:template>

</xsl:stylesheet>
